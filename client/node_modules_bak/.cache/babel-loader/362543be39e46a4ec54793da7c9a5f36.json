{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport { Observable, ApolloLink } from 'apollo-link';\n\nvar OperationBatcher = function () {\n  function OperationBatcher(_a) {\n    var batchInterval = _a.batchInterval,\n        batchMax = _a.batchMax,\n        batchHandler = _a.batchHandler,\n        batchKey = _a.batchKey;\n    this.queuedRequests = new Map();\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n\n    this.batchKey = batchKey || function () {\n      return '';\n    };\n  }\n\n  OperationBatcher.prototype.enqueueRequest = function (request) {\n    var _this = this;\n\n    var requestCopy = __assign({}, request);\n\n    var queued = false;\n    var key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable(function (observer) {\n        if (!_this.queuedRequests.has(key)) {\n          _this.queuedRequests.set(key, []);\n        }\n\n        if (!queued) {\n          _this.queuedRequests.get(key).push(requestCopy);\n\n          queued = true;\n        }\n\n        requestCopy.next = requestCopy.next || [];\n        if (observer.next) requestCopy.next.push(observer.next.bind(observer));\n        requestCopy.error = requestCopy.error || [];\n        if (observer.error) requestCopy.error.push(observer.error.bind(observer));\n        requestCopy.complete = requestCopy.complete || [];\n        if (observer.complete) requestCopy.complete.push(observer.complete.bind(observer));\n\n        if (_this.queuedRequests.get(key).length === 1) {\n          _this.scheduleQueueConsumption(key);\n        }\n\n        if (_this.queuedRequests.get(key).length === _this.batchMax) {\n          _this.consumeQueue(key);\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  };\n\n  OperationBatcher.prototype.consumeQueue = function (key) {\n    var requestKey = key || '';\n    var queuedRequests = this.queuedRequests.get(requestKey);\n\n    if (!queuedRequests) {\n      return;\n    }\n\n    this.queuedRequests.delete(requestKey);\n    var requests = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.operation;\n    });\n    var forwards = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.forward;\n    });\n    var observables = [];\n    var nexts = [];\n    var errors = [];\n    var completes = [];\n    queuedRequests.forEach(function (batchableRequest, index) {\n      observables.push(batchableRequest.observable);\n      nexts.push(batchableRequest.next);\n      errors.push(batchableRequest.error);\n      completes.push(batchableRequest.complete);\n    });\n    var batchedObservable = this.batchHandler(requests, forwards) || Observable.of();\n\n    var onError = function onError(error) {\n      errors.forEach(function (rejecters) {\n        if (rejecters) {\n          rejecters.forEach(function (e) {\n            return e(error);\n          });\n        }\n      });\n    };\n\n    batchedObservable.subscribe({\n      next: function next(results) {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          var error = new Error(\"server returned results with length \" + results.length + \", expected length of \" + nexts.length);\n          error.result = results;\n          return onError(error);\n        }\n\n        results.forEach(function (result, index) {\n          if (nexts[index]) {\n            nexts[index].forEach(function (next) {\n              return next(result);\n            });\n          }\n        });\n      },\n      error: onError,\n      complete: function complete() {\n        completes.forEach(function (complete) {\n          if (complete) {\n            complete.forEach(function (c) {\n              return c();\n            });\n          }\n        });\n      }\n    });\n    return observables;\n  };\n\n  OperationBatcher.prototype.scheduleQueueConsumption = function (key) {\n    var _this = this;\n\n    var requestKey = key || '';\n    setTimeout(function () {\n      if (_this.queuedRequests.get(requestKey) && _this.queuedRequests.get(requestKey).length) {\n        _this.consumeQueue(requestKey);\n      }\n    }, this.batchInterval);\n  };\n\n  return OperationBatcher;\n}();\n\nvar BatchLink = function (_super) {\n  __extends(BatchLink, _super);\n\n  function BatchLink(fetchParams) {\n    var _this = _super.call(this) || this;\n\n    var _a = fetchParams || {},\n        _b = _a.batchInterval,\n        batchInterval = _b === void 0 ? 10 : _b,\n        _c = _a.batchMax,\n        batchMax = _c === void 0 ? 0 : _c,\n        _d = _a.batchHandler,\n        batchHandler = _d === void 0 ? function () {\n      return null;\n    } : _d,\n        _e = _a.batchKey,\n        batchKey = _e === void 0 ? function () {\n      return '';\n    } : _e;\n\n    _this.batcher = new OperationBatcher({\n      batchInterval: batchInterval,\n      batchMax: batchMax,\n      batchHandler: batchHandler,\n      batchKey: batchKey\n    });\n\n    if (fetchParams.batchHandler.length <= 1) {\n      _this.request = function (operation) {\n        return _this.batcher.enqueueRequest({\n          operation: operation\n        });\n      };\n    }\n\n    return _this;\n  }\n\n  BatchLink.prototype.request = function (operation, forward) {\n    return this.batcher.enqueueRequest({\n      operation: operation,\n      forward: forward\n    });\n  };\n\n  return BatchLink;\n}(ApolloLink);\n\nexport { BatchLink, OperationBatcher };","map":null,"metadata":{},"sourceType":"module"}