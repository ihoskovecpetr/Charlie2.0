{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport Version from './version';\nimport { AlignmentPatternFinder } from './alignpat';\nimport GridSampler from './grid';\nimport { FinderPatternFinder } from './findpat';\n\nfunction PerspectiveTransform(a11, a21, a31, a12, a22, a32, a13, a23, a33) {\n  this.a11 = a11;\n  this.a12 = a12;\n  this.a13 = a13;\n  this.a21 = a21;\n  this.a22 = a22;\n  this.a23 = a23;\n  this.a31 = a31;\n  this.a32 = a32;\n  this.a33 = a33;\n}\n\nPerspectiveTransform.prototype.transformPoints1 = function (points) {\n  var max = points.length;\n  var a11 = this.a11;\n  var a12 = this.a12;\n  var a13 = this.a13;\n  var a21 = this.a21;\n  var a22 = this.a22;\n  var a23 = this.a23;\n  var a31 = this.a31;\n  var a32 = this.a32;\n  var a33 = this.a33;\n\n  for (var i = 0; i < max; i += 2) {\n    var x = points[i];\n    var y = points[i + 1];\n    var denominator = a13 * x + a23 * y + a33;\n    points[i] = (a11 * x + a21 * y + a31) / denominator;\n    points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n  }\n};\n\nPerspectiveTransform.prototype.transformPoints2 = function (xValues, yValues) {\n  var n = xValues.length;\n\n  for (var i = 0; i < n; i++) {\n    var x = xValues[i];\n    var y = yValues[i];\n    var denominator = this.a13 * x + this.a23 * y + this.a33;\n    xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;\n    yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;\n  }\n};\n\nPerspectiveTransform.prototype.buildAdjoint = function () {\n  // Adjoint is the transpose of the cofactor matrix:\n  return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n};\n\nPerspectiveTransform.prototype.times = function (other) {\n  return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n};\n\nPerspectiveTransform.quadrilateralToQuadrilateral = function (x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {\n  var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n  var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n  return sToQ.times(qToS);\n};\n\nPerspectiveTransform.squareToQuadrilateral = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n  var dy2 = y3 - y2;\n  var dy3 = y0 - y1 + y2 - y3;\n\n  if (dy2 == 0.0 && dy3 == 0.0) {\n    return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n  } else {\n    var dx1 = x1 - x2;\n    var dx2 = x3 - x2;\n    var dx3 = x0 - x1 + x2 - x3;\n    var dy1 = y1 - y2;\n    var denominator = dx1 * dy2 - dx2 * dy1;\n    var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n    var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n    return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n  }\n};\n\nPerspectiveTransform.quadrilateralToSquare = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n  // Here, the adjoint serves as the inverse:\n  return this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();\n};\n\nfunction DetectorResult(bits, points) {\n  this.bits = bits;\n  this.points = points;\n}\n\nexport default function Detector(image) {\n  this.image = image;\n  this.resultPointCallback = null;\n}\n\nDetector.prototype.sizeOfBlackWhiteBlackRun = function (fromX, fromY, toX, toY) {\n  // Mild variant of Bresenham's algorithm;\n  // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n  var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n  if (steep) {\n    var temp = fromX;\n    fromX = fromY;\n    fromY = temp;\n    temp = toX;\n    toX = toY;\n    toY = temp;\n  }\n\n  var dx = Math.abs(toX - fromX);\n  var dy = Math.abs(toY - fromY);\n  var error = -dx >> 1;\n  var ystep = fromY < toY ? 1 : -1;\n  var xstep = fromX < toX ? 1 : -1;\n  var state = 0; // In black pixels, looking for white, first or second time\n\n  for (var x = fromX, y = fromY; x != toX; x += xstep) {\n    var realX = steep ? y : x;\n    var realY = steep ? x : y;\n\n    if (state == 1) {\n      // In white pixels, looking for black\n      if (this.image.data[realX + realY * this.image.width]) {\n        state++;\n      }\n    } else {\n      if (!this.image.data[realX + realY * this.image.width]) {\n        state++;\n      }\n    }\n\n    if (state == 3) {\n      // Found black, white, black, and stumbled back onto white; done\n      var diffX = x - fromX;\n      var diffY = y - fromY;\n      return Math.sqrt(diffX * diffX + diffY * diffY);\n    }\n\n    error += dy;\n\n    if (error > 0) {\n      if (y == toY) {\n        break;\n      }\n\n      y += ystep;\n      error -= dx;\n    }\n  }\n\n  var diffX2 = toX - fromX;\n  var diffY2 = toY - fromY;\n  return Math.sqrt(diffX2 * diffX2 + diffY2 * diffY2);\n};\n\nDetector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX, fromY, toX, toY) {\n  var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY); // Now count other way -- don't run off image though of course\n\n  var scale = 1.0;\n  var otherToX = fromX - (toX - fromX);\n\n  if (otherToX < 0) {\n    scale = fromX / (fromX - otherToX);\n    otherToX = 0;\n  } else if (otherToX >= this.image.width) {\n    scale = (this.image.width - 1 - fromX) / (otherToX - fromX);\n    otherToX = this.image.width - 1;\n  }\n\n  var otherToY = Math.floor(fromY - (toY - fromY) * scale);\n  scale = 1.0;\n\n  if (otherToY < 0) {\n    scale = fromY / (fromY - otherToY);\n    otherToY = 0;\n  } else if (otherToY >= this.image.height) {\n    scale = (this.image.height - 1 - fromY) / (otherToY - fromY);\n    otherToY = this.image.height - 1;\n  }\n\n  otherToX = Math.floor(fromX + (otherToX - fromX) * scale);\n  result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n  return result - 1.0; // -1 because we counted the middle pixel twice\n};\n\nDetector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n  var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.X), Math.floor(pattern.Y), Math.floor(otherPattern.X), Math.floor(otherPattern.Y));\n  var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor(pattern.X), Math.floor(pattern.Y));\n\n  if (isNaN(moduleSizeEst1)) {\n    return moduleSizeEst2 / 7.0;\n  }\n\n  if (isNaN(moduleSizeEst2)) {\n    return moduleSizeEst1 / 7.0;\n  } // Average them, and divide by 7 since we've counted the width of 3 black modules,\n  // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n\n\n  return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n};\n\nDetector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n  // Take the average\n  return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n};\n\nDetector.prototype.distance = function (pattern1, pattern2) {\n  var xDiff = pattern1.X - pattern2.X;\n  var yDiff = pattern1.Y - pattern2.Y;\n  return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n};\n\nDetector.prototype.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize) {\n  var tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);\n  var tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);\n  var dimension = (tltrCentersDimension + tlblCentersDimension >> 1) + 7;\n\n  switch (dimension & 0x03) {\n    // mod 4\n    case 0:\n      dimension++;\n      break;\n    // 1? do nothing\n\n    case 2:\n      dimension--;\n      break;\n\n    case 3:\n      throw \"Error\";\n  }\n\n  return dimension;\n};\n\nDetector.prototype.findAlignmentInRegion = function (overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {\n  // Look for an alignment pattern (3 modules in size) around where it\n  // should be\n  var allowance = Math.floor(allowanceFactor * overallEstModuleSize);\n  var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n  var alignmentAreaRightX = Math.min(this.image.width - 1, estAlignmentX + allowance);\n\n  if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n    throw \"Error\";\n  }\n\n  var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n  var alignmentAreaBottomY = Math.min(this.image.height - 1, estAlignmentY + allowance);\n  var alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n  return alignmentFinder.find();\n};\n\nDetector.prototype.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension) {\n  var dimMinusThree = dimension - 3.5;\n  var bottomRightX;\n  var bottomRightY;\n  var sourceBottomRightX;\n  var sourceBottomRightY;\n\n  if (alignmentPattern != null) {\n    bottomRightX = alignmentPattern.X;\n    bottomRightY = alignmentPattern.Y;\n    sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;\n  } else {\n    // Don't have an alignment pattern, just make up the bottom-right point\n    bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n    bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;\n    sourceBottomRightX = sourceBottomRightY = dimMinusThree;\n  }\n\n  var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);\n  return transform;\n};\n\nDetector.prototype.sampleGrid = function (image, transform, dimension) {\n  var sampler = GridSampler;\n  return sampler.sampleGrid3(image, dimension, transform);\n};\n\nDetector.prototype.processFinderPatternInfo = function (info) {\n  var topLeft = info.topLeft;\n  var topRight = info.topRight;\n  var bottomLeft = info.bottomLeft;\n  var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n\n  if (moduleSize < 1.0) {\n    throw \"Error\";\n  }\n\n  var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n  var provisionalVersion = Version.getProvisionalVersionForDimension(dimension);\n  var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;\n  var alignmentPattern = null; // Anything above version 1 has an alignment pattern\n\n  if (provisionalVersion.alignmentPatternCenters.length > 0) {\n    // Guess where a \"bottom right\" finder pattern would have been\n    var bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n    var bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y; // Estimate that alignment pattern is closer by 3 modules\n    // from \"bottom right\" to known top left location\n\n    var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n    var estAlignmentX = Math.floor(topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));\n    var estAlignmentY = Math.floor(topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y)); // Kind of arbitrary -- expand search radius before giving up\n\n    for (var i = 4; i <= 16; i <<= 1) {\n      //try\n      //{\n      alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n      break; //}\n      //catch (re)\n      //{\n      // try next round\n      //}\n    } // If we didn't find alignment pattern... well try anyway without it\n\n  }\n\n  var transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n  var bits = this.sampleGrid(this.image, transform, dimension);\n  var points;\n\n  if (alignmentPattern == null) {\n    points = [bottomLeft, topLeft, topRight];\n  } else {\n    points = [bottomLeft, topLeft, topRight, alignmentPattern];\n  }\n\n  return new DetectorResult(bits, points);\n};\n\nDetector.prototype.detect = function () {\n  var info = new FinderPatternFinder().findFinderPattern(this.image);\n  return this.processFinderPatternInfo(info);\n};","map":null,"metadata":{},"sourceType":"module"}