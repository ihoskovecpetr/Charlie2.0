{"ast":null,"code":"const EventEmitter = require('events');\n\nconst ZXing = require('./zxing')();\n\nconst Visibility = require('visibilityjs');\n\nconst StateMachine = require('fsm-as-promised');\n\nclass ScanProvider {\n  constructor(emitter, analyzer, captureImage, scanPeriod, refractoryPeriod) {\n    this.scanPeriod = scanPeriod;\n    this.captureImage = captureImage;\n    this.refractoryPeriod = refractoryPeriod;\n    this._emitter = emitter;\n    this._frameCount = 0;\n    this._analyzer = analyzer;\n    this._lastResult = null;\n    this._active = false;\n  }\n\n  start() {\n    this._active = true;\n    requestAnimationFrame(() => this._scan());\n  }\n\n  stop() {\n    this._active = false;\n  }\n\n  scan() {\n    return this._analyze(false);\n  }\n\n  _analyze(skipDups) {\n    let analysis = this._analyzer.analyze();\n\n    if (!analysis) {\n      return null;\n    }\n\n    let result = analysis.result,\n        canvas = analysis.canvas;\n\n    if (!result) {\n      return null;\n    }\n\n    if (skipDups && result === this._lastResult) {\n      return null;\n    }\n\n    clearTimeout(this.refractoryTimeout);\n    this.refractoryTimeout = setTimeout(() => {\n      this._lastResult = null;\n    }, this.refractoryPeriod);\n    let image = this.captureImage ? canvas.toDataURL('image/webp', 0.8) : null;\n    this._lastResult = result;\n    let payload = {\n      content: result\n    };\n\n    if (image) {\n      payload.image = image;\n    }\n\n    return payload;\n  }\n\n  _scan() {\n    if (!this._active) {\n      return;\n    }\n\n    requestAnimationFrame(() => this._scan());\n\n    if (++this._frameCount !== this.scanPeriod) {\n      return;\n    } else {\n      this._frameCount = 0;\n    }\n\n    let result = this._analyze(true);\n\n    if (result) {\n      setTimeout(() => {\n        this._emitter.emit('scan', result.content, result.image || null);\n      }, 0);\n    }\n  }\n\n}\n\nclass Analyzer {\n  constructor(video) {\n    this.video = video;\n    this.imageBuffer = null;\n    this.sensorLeft = null;\n    this.sensorTop = null;\n    this.sensorWidth = null;\n    this.sensorHeight = null;\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.display = 'none';\n    this.canvasContext = null;\n    this.decodeCallback = ZXing.Runtime.addFunction(function (ptr, len, resultIndex, resultCount) {\n      var result = new Uint8Array(ZXing.HEAPU8.buffer, ptr, len);\n      var str = String.fromCharCode.apply(null, result);\n\n      if (resultIndex === 0) {\n        window.zxDecodeResult = '';\n      }\n\n      window.zxDecodeResult += str;\n    });\n  }\n\n  analyze() {\n    if (!this.video.videoWidth) {\n      return null;\n    }\n\n    if (!this.imageBuffer) {\n      let videoWidth = this.video.videoWidth;\n      let videoHeight = this.video.videoHeight;\n      this.sensorWidth = videoWidth;\n      this.sensorHeight = videoHeight;\n      this.sensorLeft = Math.floor(videoWidth / 2 - this.sensorWidth / 2);\n      this.sensorTop = Math.floor(videoHeight / 2 - this.sensorHeight / 2);\n      this.canvas.width = this.sensorWidth;\n      this.canvas.height = this.sensorHeight;\n      this.canvasContext = this.canvas.getContext('2d');\n      this.imageBuffer = ZXing._resize(this.sensorWidth, this.sensorHeight);\n      return null;\n    }\n\n    this.canvasContext.drawImage(this.video, this.sensorLeft, this.sensorTop, this.sensorWidth, this.sensorHeight);\n    let data = this.canvasContext.getImageData(0, 0, this.sensorWidth, this.sensorHeight).data;\n\n    for (var i = 0, j = 0; i < data.length; i += 4, j++) {\n      let _ref = [data[i], data[i + 1], data[i + 2]],\n          r = _ref[0],\n          g = _ref[1],\n          b = _ref[2];\n      ZXing.HEAPU8[this.imageBuffer + j] = Math.trunc((r + g + b) / 3);\n    }\n\n    let err = ZXing._decode_qr(this.decodeCallback);\n\n    if (err) {\n      return null;\n    }\n\n    let result = window.zxDecodeResult;\n\n    if (result != null) {\n      return {\n        result: result,\n        canvas: this.canvas\n      };\n    }\n\n    return null;\n  }\n\n}\n\nclass Scanner extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.video = this._configureVideo(opts);\n    this.mirror = opts.mirror !== false;\n    this.backgroundScan = opts.backgroundScan || false;\n    this._continuous = opts.continuous !== false;\n    this._analyzer = new Analyzer(this.video);\n    this._camera = null;\n    let captureImage = opts.captureImage || false;\n    let scanPeriod = opts.scanPeriod || 1;\n    let refractoryPeriod = opts.refractoryPeriod || 5 * 1000;\n    this._scanner = new ScanProvider(this, this._analyzer, captureImage, scanPeriod, refractoryPeriod);\n    this._fsm = this._createStateMachine();\n    Visibility.change((e, state) => {\n      if (state === 'visible') {\n        setTimeout(() => {\n          if (this._fsm.can('activate')) {\n            this._fsm.activate();\n          }\n        }, 0);\n      } else {\n        if (!this.backgroundScan && this._fsm.can('deactivate')) {\n          this._fsm.deactivate();\n        }\n      }\n    });\n    this.addListener('active', () => {\n      this.video.classList.remove('inactive');\n      this.video.classList.add('active');\n    });\n    this.addListener('inactive', () => {\n      this.video.classList.remove('active');\n      this.video.classList.add('inactive');\n    });\n    this.emit('inactive');\n  }\n\n  scan() {\n    return this._scanner.scan();\n  }\n\n  async start(camera = null) {\n    if (this._fsm.can('start')) {\n      await this._fsm.start(camera);\n    } else {\n      await this._fsm.stop();\n      await this._fsm.start(camera);\n    }\n  }\n\n  async stop() {\n    if (this._fsm.can('stop')) {\n      await this._fsm.stop();\n    }\n  }\n\n  set captureImage(capture) {\n    this._scanner.captureImage = capture;\n  }\n\n  get captureImage() {\n    return this._scanner.captureImage;\n  }\n\n  set scanPeriod(period) {\n    this._scanner.scanPeriod = period;\n  }\n\n  get scanPeriod() {\n    return this._scanner.scanPeriod;\n  }\n\n  set refractoryPeriod(period) {\n    this._scanner.refractoryPeriod = period;\n  }\n\n  get refractoryPeriod() {\n    return this._scanner.refractoryPeriod;\n  }\n\n  set continuous(continuous) {\n    this._continuous = continuous;\n\n    if (continuous && this._fsm.current === 'active') {\n      this._scanner.start();\n    } else {\n      this._scanner.stop();\n    }\n  }\n\n  get continuous() {\n    return this._continuous;\n  }\n\n  set mirror(mirror) {\n    this._mirror = mirror;\n\n    if (mirror) {\n      this.video.style.MozTransform = 'scaleX(-1)';\n      this.video.style.webkitTransform = 'scaleX(-1)';\n      this.video.style.OTransform = 'scaleX(-1)';\n      this.video.style.msFilter = 'FlipH';\n      this.video.style.filter = 'FlipH';\n      this.video.style.transform = 'scaleX(-1)';\n    } else {\n      this.video.style.MozTransform = null;\n      this.video.style.webkitTransform = null;\n      this.video.style.OTransform = null;\n      this.video.style.msFilter = null;\n      this.video.style.filter = null;\n      this.video.style.transform = null;\n    }\n  }\n\n  get mirror() {\n    return this._mirror;\n  }\n\n  async _enableScan(camera) {\n    this._camera = camera || this._camera;\n\n    if (!this._camera) {\n      throw new Error('Camera is not defined.');\n    }\n\n    let streamUrl = await this._camera.start();\n    this.video.src = streamUrl;\n\n    if (this._continuous) {\n      this._scanner.start();\n    }\n  }\n\n  _disableScan() {\n    this.video.src = '';\n\n    if (this._scanner) {\n      this._scanner.stop();\n    }\n\n    if (this._camera) {\n      this._camera.stop();\n    }\n  }\n\n  _configureVideo(opts) {\n    if (opts.video) {\n      if (opts.video.tagName !== 'VIDEO') {\n        throw new Error('Video must be a <video> element.');\n      }\n    }\n\n    var video = opts.video || document.createElement('video');\n    video.setAttribute('autoplay', 'autoplay');\n    return video;\n  }\n\n  _createStateMachine() {\n    return StateMachine.create({\n      initial: 'stopped',\n      events: [{\n        name: 'start',\n        from: 'stopped',\n        to: 'started'\n      }, {\n        name: 'stop',\n        from: ['started', 'active', 'inactive'],\n        to: 'stopped'\n      }, {\n        name: 'activate',\n        from: ['started', 'inactive'],\n        to: ['active', 'inactive'],\n        condition: function (options) {\n          if (Visibility.state() === 'visible' || this.backgroundScan) {\n            return 'active';\n          } else {\n            return 'inactive';\n          }\n        }\n      }, {\n        name: 'deactivate',\n        from: ['started', 'active'],\n        to: 'inactive'\n      }],\n      callbacks: {\n        onenteractive: async options => {\n          await this._enableScan(options.args[0]);\n          this.emit('active');\n        },\n        onleaveactive: () => {\n          this._disableScan();\n\n          this.emit('inactive');\n        },\n        onenteredstarted: async options => {\n          await this._fsm.activate(options.args[0]);\n        }\n      }\n    });\n  }\n\n}\n\nmodule.exports = Scanner;","map":null,"metadata":{},"sourceType":"script"}