{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nexport default function GF256Poly(field, coefficients) {\n  if (coefficients == null || coefficients.length == 0) {\n    throw \"System.ArgumentException\";\n  }\n\n  this.field = field;\n  var coefficientsLength = coefficients.length;\n\n  if (coefficientsLength > 1 && coefficients[0] == 0) {\n    // Leading term must be non-zero for anything except the constant polynomial \"0\"\n    var firstNonZero = 1;\n\n    while (firstNonZero < coefficientsLength && coefficients[firstNonZero] == 0) {\n      firstNonZero++;\n    }\n\n    if (firstNonZero == coefficientsLength) {\n      this.coefficients = field.Zero.coefficients;\n    } else {\n      this.coefficients = new Array(coefficientsLength - firstNonZero);\n\n      for (var i = 0; i < this.coefficients.length; i++) this.coefficients[i] = 0;\n\n      for (var ci = 0; ci < this.coefficients.length; ci++) this.coefficients[ci] = coefficients[firstNonZero + ci];\n    }\n  } else {\n    this.coefficients = coefficients;\n  }\n}\nObject.defineProperty(GF256Poly.prototype, \"Zero\", {\n  get: function () {\n    return this.coefficients[0] == 0;\n  }\n});\nObject.defineProperty(GF256Poly.prototype, \"Degree\", {\n  get: function () {\n    return this.coefficients.length - 1;\n  }\n});\n\nGF256Poly.prototype.getCoefficient = function (degree) {\n  return this.coefficients[this.coefficients.length - 1 - degree];\n};\n\nGF256Poly.prototype.evaluateAt = function (a) {\n  if (a == 0) {\n    // Just return the x^0 coefficient\n    return this.getCoefficient(0);\n  }\n\n  var size = this.coefficients.length;\n\n  if (a == 1) {\n    // Just the sum of the coefficients\n    var result = 0;\n\n    for (var i = 0; i < size; i++) {\n      result = this.field.addOrSubtract(result, this.coefficients[i]);\n    }\n\n    return result;\n  }\n\n  var result2 = this.coefficients[0];\n\n  for (var i = 1; i < size; i++) {\n    result2 = this.field.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);\n  }\n\n  return result2;\n};\n\nGF256Poly.prototype.addOrSubtract = function (other) {\n  if (this.field != other.field) {\n    throw \"GF256Polys do not have same GF256 field\";\n  }\n\n  if (this.Zero) {\n    return other;\n  }\n\n  if (other.Zero) {\n    return this;\n  }\n\n  var smallerCoefficients = this.coefficients;\n  var largerCoefficients = other.coefficients;\n\n  if (smallerCoefficients.length > largerCoefficients.length) {\n    var temp = smallerCoefficients;\n    smallerCoefficients = largerCoefficients;\n    largerCoefficients = temp;\n  }\n\n  var sumDiff = new Array(largerCoefficients.length);\n  var lengthDiff = largerCoefficients.length - smallerCoefficients.length; // Copy high-order terms only found in higher-degree polynomial's coefficients\n\n  for (var ci = 0; ci < lengthDiff; ci++) sumDiff[ci] = largerCoefficients[ci];\n\n  for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n    sumDiff[i] = this.field.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n  }\n\n  return new GF256Poly(this.field, sumDiff);\n};\n\nGF256Poly.prototype.multiply1 = function (other) {\n  if (this.field != other.field) {\n    throw \"GF256Polys do not have same GF256 field\";\n  }\n\n  if (this.Zero || other.Zero) {\n    return this.field.Zero;\n  }\n\n  var aCoefficients = this.coefficients;\n  var aLength = aCoefficients.length;\n  var bCoefficients = other.coefficients;\n  var bLength = bCoefficients.length;\n  var product = new Array(aLength + bLength - 1);\n\n  for (var i = 0; i < aLength; i++) {\n    var aCoeff = aCoefficients[i];\n\n    for (var j = 0; j < bLength; j++) {\n      product[i + j] = this.field.addOrSubtract(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n    }\n  }\n\n  return new GF256Poly(this.field, product);\n};\n\nGF256Poly.prototype.multiply2 = function (scalar) {\n  if (scalar == 0) {\n    return this.field.Zero;\n  }\n\n  if (scalar == 1) {\n    return this;\n  }\n\n  var size = this.coefficients.length;\n  var product = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    product[i] = this.field.multiply(this.coefficients[i], scalar);\n  }\n\n  return new GF256Poly(this.field, product);\n};\n\nGF256Poly.prototype.multiplyByMonomial = function (degree, coefficient) {\n  if (degree < 0) {\n    throw \"System.ArgumentException\";\n  }\n\n  if (coefficient == 0) {\n    return this.field.Zero;\n  }\n\n  var size = this.coefficients.length;\n  var product = new Array(size + degree);\n\n  for (var i = 0; i < product.length; i++) product[i] = 0;\n\n  for (var i = 0; i < size; i++) {\n    product[i] = this.field.multiply(this.coefficients[i], coefficient);\n  }\n\n  return new GF256Poly(this.field, product);\n};\n\nGF256Poly.prototype.divide = function (other) {\n  if (this.field != other.field) {\n    throw \"GF256Polys do not have same GF256 field\";\n  }\n\n  if (other.Zero) {\n    throw \"Divide by 0\";\n  }\n\n  var quotient = this.field.Zero;\n  var remainder = this;\n  var denominatorLeadingTerm = other.getCoefficient(other.Degree);\n  var inverseDenominatorLeadingTerm = this.field.inverse(denominatorLeadingTerm);\n\n  while (remainder.Degree >= other.Degree && !remainder.Zero) {\n    var degreeDifference = remainder.Degree - other.Degree;\n    var scale = this.field.multiply(remainder.getCoefficient(remainder.Degree), inverseDenominatorLeadingTerm);\n    var term = other.multiplyByMonomial(degreeDifference, scale);\n    var iterationQuotient = this.field.buildMonomial(degreeDifference, scale);\n    quotient = quotient.addOrSubtract(iterationQuotient);\n    remainder = remainder.addOrSubtract(term);\n  }\n\n  return [quotient, remainder];\n};","map":null,"metadata":{},"sourceType":"module"}