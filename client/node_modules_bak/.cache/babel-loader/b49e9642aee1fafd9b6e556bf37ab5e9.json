{"ast":null,"code":"/*\n * @author Vlad Stirbu\n * @license MIT\n *\n * Copyright Â© 2014-2016\n */\n'use strict';\n\nvar FsmError = require('./fsm-error');\n\nvar stampit = require('stampit');\n\nvar _ = require('lodash');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar AssignFirstArgument = stampit({\n  init: function init(opts) {\n    Object.assign(this, opts);\n  }\n});\nvar StateMachine = stampit({\n  props: {\n    // can be an object or an array\n    events: [],\n    pseudoStates: {},\n    responses: {},\n    pseudoEvents: {},\n    callbacks: {},\n    states: {},\n    final: null,\n    initial: 'none',\n    current: 'none'\n  },\n  statics: {\n    Promise: global.Promise || require('es6-promise').Promise,\n    FsmError: FsmError,\n    callbackPrefix: 'on',\n    noChoiceFound: 'no-choice',\n    type: function type(options) {\n      var Type = this.Type;\n\n      if (options.from === options.to || _.isUndefined(options.to)) {\n        return Type.NOOP;\n      } else if (options.from === '*') {\n        return Type.GENERAL;\n      }\n\n      return Type.INTER;\n    },\n    Type: {\n      NOOP: 0,\n      INTER: 1,\n      GENERAL: 2\n    },\n    isConditional: function isConditional(event) {\n      return _.isFunction(event.condition) && _.isArray(event.to);\n    },\n    pseudoEvent: function pseudoEvent(state, name) {\n      return state + '--' + name;\n    }\n  },\n  methods: {\n    emit: _.noop,\n    canTransition: function canTransition(options) {\n      var factory = this.factory;\n      var Type = factory.Type;\n\n      switch (factory.type(options)) {\n        case Type.NOOP:\n          if (this.inTransition) {\n            throw new factory.FsmError('Previous transition pending', options);\n          }\n\n          break;\n\n        case Type.INTER:\n          if (this.states[this.current].noopTransition > 0 || this.inTransition) {\n            throw new factory.FsmError('Previous transition pending', options);\n          }\n\n          break;\n\n        default:\n      }\n\n      return options;\n    },\n    can: function can(name) {\n      return Boolean(this.events[name][this.current]);\n    },\n    cannot: function cannot(name) {\n      return !this.can(name);\n    },\n    hasState: function hasState(state) {\n      return Boolean(this.states[state]);\n    },\n    is: function is(state) {\n      return state == this.current;\n    },\n    isFinal: function isFinal(state) {\n      state = state || this.current;\n\n      if (_.isArray(this.final)) {\n        return _.includes(this.final, state);\n      }\n\n      return this.final === state;\n    },\n    isValidEvent: function isValidEvent(options) {\n      if (this.cannot(options.name)) {\n        throw new this.factory.FsmError('Invalid event in current state', options);\n      }\n\n      return options;\n    },\n    addEvents: function addEvents(events) {\n      _.forEach(events, function (event) {\n        this.addEvent(event);\n      }.bind(this));\n    },\n    addEvent: function addEvent(event) {\n      this.events[event.name] = this.events[event.name] || {}; //NOTE: Add the choice pseudo-state for conditional transition\n\n      if (this.factory.isConditional(event)) {\n        return this.addConditionalEvent(event);\n      }\n\n      this.addBasicEvent(event);\n    },\n    addBasicEvent: function addBasicEvent(event) {\n      if (_.isArray(event.to)) {\n        throw new this.factory.FsmError('Ambigous transition', event);\n      }\n\n      event.from = [].concat(event.from || []);\n\n      _.forEach(event.from, function (from) {\n        this.events[event.name][from] = event.to || from;\n      }.bind(this));\n    },\n    addConditionalEvent: function addConditionalEvent(event) {\n      var pseudoState;\n      var factory = this.factory;\n      var callbackPrefix = factory.callbackPrefix;\n      var noChoiceFound = factory.noChoiceFound;\n      var pseudoEvent = factory.pseudoEvent;\n      var Promise = factory.Promise;\n\n      if (_.isArray(event.from)) {\n        return _.forEach(event.from, function (from) {\n          this.addConditionalEvent({\n            name: event.name,\n            from: from,\n            to: event.to,\n            condition: event.condition\n          });\n        }.bind(this));\n      }\n\n      pseudoState = event.from + '__' + event.name;\n      this.pseudoStates[pseudoState] = event.from;\n      this.addState(pseudoState);\n      this.addEvent({\n        name: event.name,\n        from: event.from,\n        to: pseudoState\n      });\n      this.addEvent({\n        name: pseudoEvent(pseudoState, noChoiceFound),\n        from: pseudoState,\n        to: event.from\n      });\n      this.pseudoEvents[pseudoEvent(pseudoState, noChoiceFound)] = event.name;\n\n      _.forEach(event.to, function (toState) {\n        this.addEvent({\n          name: pseudoEvent(pseudoState, toState),\n          from: pseudoState,\n          to: toState\n        });\n        this.pseudoEvents[pseudoEvent(pseudoState, toState)] = event.name;\n      }.bind(this));\n\n      this.callbacks[callbackPrefix + 'entered' + pseudoState] = function (options) {\n        var target = this.target;\n\n        _.defaults(options, {\n          args: []\n        });\n\n        return new Promise(function (resolve) {\n          resolve(event.condition(options));\n        }).then(function (index) {\n          var toState;\n\n          if (_.isNumber(index)) {\n            toState = event.to[index];\n          } else if (_.includes(event.to, index)) {\n            toState = index;\n          }\n\n          if (_.isUndefined(toState)) {\n            return target[pseudoEvent(pseudoState, noChoiceFound)]().then(function () {\n              throw new factory.FsmError('Choice index out of range', event);\n            });\n          } else {\n            return target[pseudoEvent(pseudoState, toState)].apply(target, options.args);\n          }\n        }.bind(this));\n      }.bind(this);\n    },\n    addState: function addState(state) {\n      var states = this.states;\n      state = [].concat(state || []);\n      state.forEach(function (name) {\n        states[name] = states[name] || {\n          noopTransition: 0\n        };\n      });\n    },\n    preprocessPseudoState: function preprocessPseudoState(name, options) {\n      var responses = this.responses; // transition to choice state in a conditional event\n\n      Object.defineProperty(options, 'res', {\n        get: function getRes() {\n          return responses[name];\n        },\n        set: function setRes(value) {\n          responses[name] = value;\n        }\n      }); // reset previous results\n\n      delete responses[name];\n      return options;\n    },\n    preprocessPseudoEvent: function preprocessPseudoEvent(name, options) {\n      // transition from choice state in a conditional event\n      var pseudoEvent = this.pseudoEvents[name];\n      var responses = this.responses;\n      var pseudoStates = this.pseudoStates;\n      var pOptions = {\n        name: pseudoEvent,\n        from: pseudoStates[this.current],\n        to: options.to,\n        args: options.args\n      };\n      Object.defineProperties(pOptions, {\n        res: {\n          get: function get() {\n            return responses[pseudoEvent];\n          },\n          set: function set(val) {\n            responses[pseudoEvent] = val;\n          }\n        }\n      });\n      return pOptions;\n    },\n    buildEvent: function buildEvent(name) {\n      var callbacks = this.callbacks;\n      var pseudoEvents = this.pseudoEvents;\n      var pseudoStates = this.pseudoStates;\n      var events = this.events;\n      var Type = this.factory.Type;\n      var callbackPrefix = this.factory.callbackPrefix;\n      return function triggerEvent() {\n        var args = _.toArray(arguments);\n\n        var current = this.current;\n        var target = this.target;\n        var options = {\n          name: name,\n          from: current,\n          to: events[name][current],\n          args: args\n        };\n        var pOptions;\n        var isPseudo = pseudoEvents[name];\n\n        if (pseudoStates[options.to]) {\n          options = this.preprocessPseudoState(name, options);\n        }\n\n        if (isPseudo) {\n          pOptions = this.preprocessPseudoEvent(name, options);\n        }\n\n        return new this.factory.Promise(function (resolve) {\n          resolve(options);\n        }).then(this.isValidEvent.bind(this)).then(this.canTransition.bind(this)).then(callbacks[callbackPrefix + 'leave' + current] ? callbacks[callbackPrefix + 'leave' + current].bind(target, options) : _.identity).then(callbacks.onleave ? callbacks.onleave.bind(target, options) : _.identity).then(onleavestate.bind(this, options)).then(callbacks[callbackPrefix + name] ? callbacks[callbackPrefix + name].bind(target, options) : _.identity) //in the case of the transition from choice pseudostate we provide\n        // the options of the original transition\n        .then(callbacks[callbackPrefix + 'enter' + events[name][current]] ? callbacks[callbackPrefix + 'enter' + events[name][current]].bind(target, isPseudo ? pOptions : options) : _.identity).then(callbacks.onenter ? callbacks.onenter.bind(target, isPseudo ? pOptions : options) : _.identity).then(onenterstate.bind(this, options)).then(callbacks[callbackPrefix + 'entered' + events[name][current]] ? callbacks[callbackPrefix + 'entered' + events[name][current]].bind(target, isPseudo ? pOptions : options) : _.identity).then(callbacks.onentered ? callbacks.onentered.bind(target, isPseudo ? pOptions : options) : _.identity).then(returnValue.bind(this, options)).catch(revert.bind(this));\n\n        function returnValue(options) {\n          return options.res || options;\n        }\n\n        function onleavestate(options) {\n          switch (this.factory.type(options)) {\n            case Type.NOOP:\n              this.states[this.current].noopTransition += 1;\n              break;\n\n            default:\n              this.inTransition = true;\n          }\n\n          return options;\n        }\n\n        function onenterstate(options) {\n          switch (this.factory.type(options)) {\n            case Type.NOOP:\n              this.states[this.current].noopTransition -= 1;\n              break;\n\n            default:\n              this.inTransition = false;\n              this.current = options.to;\n              this.emit('state', this.current);\n          }\n\n          return options;\n        } //NOTE: Internal error handling stub\n\n\n        function revert(err) {\n          switch (this.factory.type(options)) {\n            case Type.INTER:\n              this.inTransition = false;\n              break;\n\n            case Type.NOOP:\n              if (this.states[this.current].noopTransition > 0) {\n                this.states[this.current].noopTransition -= 1;\n              }\n\n              break;\n\n            default:\n          }\n\n          throw err;\n        }\n      }.bind(this);\n    },\n    initTarget: function initTarget(target) {\n      var mixin;\n\n      if (!_.isObject(target)) {\n        target = new EventEmitter();\n      }\n\n      if (_.isFunction(target.emit)) {\n        this.emit = function emit() {\n          return target.emit.apply(target, arguments);\n        };\n      }\n\n      mixin = _.mapValues(this.events, function (event, name) {\n        return this.buildEvent(name);\n      }.bind(this));\n\n      _.assign(target, mixin, {\n        can: this.can.bind(this),\n        cannot: this.cannot.bind(this),\n        is: this.is.bind(this),\n        hasState: this.hasState.bind(this),\n        isFinal: this.isFinal.bind(this)\n      });\n\n      Object.defineProperty(target, 'current', {\n        get: function getCurrent() {\n          return this.current;\n        }.bind(this)\n      });\n      this.target = target;\n      return target;\n    }\n  },\n  init: function init(opts, context) {\n    this.factory = context.stamp;\n    var events = this.events;\n    this.events = {};\n\n    _.forEach(events, function (event, name) {\n      if (_.isString(name)) {\n        event.name = name;\n      }\n\n      this.addEvent(event); //NOTE: Add states\n\n      this.addState(event.from);\n      this.addState(event.to);\n    }.bind(this));\n\n    this.current = this.initial; // return this.initTarget(_.first(context.args));\n\n    return this.initTarget(context.args[1]);\n  }\n});\nStateMachine = AssignFirstArgument.compose(StateMachine);\nmodule.exports = StateMachine;","map":null,"metadata":{},"sourceType":"script"}