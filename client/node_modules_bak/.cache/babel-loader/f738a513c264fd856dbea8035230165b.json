{"ast":null,"code":"/*global window */\n\n/**\n * @license countdown.js v2.6.0 http://countdownjs.org\n * Copyright (c)2006-2014 Stephen M. McKamey.\n * Licensed under The MIT License.\n */\n\n/*jshint bitwise:false */\n\n/**\n * @public\n * @type {Object|null}\n */\nvar module;\n/**\n * API entry\n * @public\n * @param {function(Object)|Date|number} start the starting date\n * @param {function(Object)|Date|number} end the ending date\n * @param {number} units the units to populate\n * @return {Object|number}\n */\n\nvar countdown =\n/**\n * @param {Object} module CommonJS Module\n */\nfunction (module) {\n  /*jshint smarttabs:true */\n  'use strict';\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MILLISECONDS = 0x001;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var SECONDS = 0x002;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MINUTES = 0x004;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var HOURS = 0x008;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var DAYS = 0x010;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var WEEKS = 0x020;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MONTHS = 0x040;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var YEARS = 0x080;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var DECADES = 0x100;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var CENTURIES = 0x200;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MILLENNIA = 0x400;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var DEFAULTS = YEARS | MONTHS | DAYS | HOURS | MINUTES | SECONDS;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MILLISECONDS_PER_SECOND = 1000;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var SECONDS_PER_MINUTE = 60;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MINUTES_PER_HOUR = 60;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var HOURS_PER_DAY = 24;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MILLISECONDS_PER_DAY = HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE * MILLISECONDS_PER_SECOND;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var DAYS_PER_WEEK = 7;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var MONTHS_PER_YEAR = 12;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var YEARS_PER_DECADE = 10;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var DECADES_PER_CENTURY = 10;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var CENTURIES_PER_MILLENNIUM = 10;\n  /**\n   * @private\n   * @param {number} x number\n   * @return {number}\n   */\n\n  var ceil = Math.ceil;\n  /**\n   * @private\n   * @param {number} x number\n   * @return {number}\n   */\n\n  var floor = Math.floor;\n  /**\n   * @private\n   * @param {Date} ref reference date\n   * @param {number} shift number of months to shift\n   * @return {number} number of days shifted\n   */\n\n  function borrowMonths(ref, shift) {\n    var prevTime = ref.getTime(); // increment month by shift\n\n    ref.setMonth(ref.getMonth() + shift); // this is the trickiest since months vary in length\n\n    return Math.round((ref.getTime() - prevTime) / MILLISECONDS_PER_DAY);\n  }\n  /**\n   * @private\n   * @param {Date} ref reference date\n   * @return {number} number of days\n   */\n\n\n  function daysPerMonth(ref) {\n    var a = ref.getTime(); // increment month by 1\n\n    var b = new Date(a);\n    b.setMonth(ref.getMonth() + 1); // this is the trickiest since months vary in length\n\n    return Math.round((b.getTime() - a) / MILLISECONDS_PER_DAY);\n  }\n  /**\n   * @private\n   * @param {Date} ref reference date\n   * @return {number} number of days\n   */\n\n\n  function daysPerYear(ref) {\n    var a = ref.getTime(); // increment year by 1\n\n    var b = new Date(a);\n    b.setFullYear(ref.getFullYear() + 1); // this is the trickiest since years (periodically) vary in length\n\n    return Math.round((b.getTime() - a) / MILLISECONDS_PER_DAY);\n  }\n  /**\n   * Applies the Timespan to the given date.\n   * \n   * @private\n   * @param {Timespan} ts\n   * @param {Date=} date\n   * @return {Date}\n   */\n\n\n  function addToDate(ts, date) {\n    date = date instanceof Date || date !== null && isFinite(date) ? new Date(+date) : new Date();\n\n    if (!ts) {\n      return date;\n    } // if there is a value field, use it directly\n\n\n    var value = +ts.value || 0;\n\n    if (value) {\n      date.setTime(date.getTime() + value);\n      return date;\n    }\n\n    value = +ts.milliseconds || 0;\n\n    if (value) {\n      date.setMilliseconds(date.getMilliseconds() + value);\n    }\n\n    value = +ts.seconds || 0;\n\n    if (value) {\n      date.setSeconds(date.getSeconds() + value);\n    }\n\n    value = +ts.minutes || 0;\n\n    if (value) {\n      date.setMinutes(date.getMinutes() + value);\n    }\n\n    value = +ts.hours || 0;\n\n    if (value) {\n      date.setHours(date.getHours() + value);\n    }\n\n    value = +ts.weeks || 0;\n\n    if (value) {\n      value *= DAYS_PER_WEEK;\n    }\n\n    value += +ts.days || 0;\n\n    if (value) {\n      date.setDate(date.getDate() + value);\n    }\n\n    value = +ts.months || 0;\n\n    if (value) {\n      date.setMonth(date.getMonth() + value);\n    }\n\n    value = +ts.millennia || 0;\n\n    if (value) {\n      value *= CENTURIES_PER_MILLENNIUM;\n    }\n\n    value += +ts.centuries || 0;\n\n    if (value) {\n      value *= DECADES_PER_CENTURY;\n    }\n\n    value += +ts.decades || 0;\n\n    if (value) {\n      value *= YEARS_PER_DECADE;\n    }\n\n    value += +ts.years || 0;\n\n    if (value) {\n      date.setFullYear(date.getFullYear() + value);\n    }\n\n    return date;\n  }\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n\n  var LABEL_MILLISECONDS = 0;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_SECONDS = 1;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_MINUTES = 2;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_HOURS = 3;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_DAYS = 4;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_WEEKS = 5;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_MONTHS = 6;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_YEARS = 7;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_DECADES = 8;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_CENTURIES = 9;\n  /**\n   * @private\n   * @const\n   * @type {number}\n   */\n\n  var LABEL_MILLENNIA = 10;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  var LABELS_SINGLUAR;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  var LABELS_PLURAL;\n  /**\n   * @private\n   * @type {string}\n   */\n\n  var LABEL_LAST;\n  /**\n   * @private\n   * @type {string}\n   */\n\n  var LABEL_DELIM;\n  /**\n   * @private\n   * @type {string}\n   */\n\n  var LABEL_NOW;\n  /**\n   * Formats a number & unit as a string\n   * \n   * @param {number} value\n   * @param {number} unit\n   * @return {string}\n   */\n\n  var formatter;\n  /**\n   * Formats a number as a string\n   * \n   * @private\n   * @param {number} value\n   * @return {string}\n   */\n\n  var formatNumber;\n  /**\n   * @private\n   * @param {number} value\n   * @param {number} unit unit index into label list\n   * @return {string}\n   */\n\n  function plurality(value, unit) {\n    return formatNumber(value) + (value === 1 ? LABELS_SINGLUAR[unit] : LABELS_PLURAL[unit]);\n  }\n  /**\n   * Formats the entries with singular or plural labels\n   * \n   * @private\n   * @param {Timespan} ts\n   * @return {Array}\n   */\n\n\n  var formatList;\n  /**\n   * Timespan representation of a duration of time\n   * \n   * @private\n   * @this {Timespan}\n   * @constructor\n   */\n\n  function Timespan() {}\n  /**\n   * Formats the Timespan as a sentence\n   * \n   * @param {string=} emptyLabel the string to use when no values returned\n   * @return {string}\n   */\n\n\n  Timespan.prototype.toString = function (emptyLabel) {\n    var label = formatList(this);\n    var count = label.length;\n\n    if (!count) {\n      return emptyLabel ? '' + emptyLabel : LABEL_NOW;\n    }\n\n    if (count === 1) {\n      return label[0];\n    }\n\n    var last = LABEL_LAST + label.pop();\n    return label.join(LABEL_DELIM) + last;\n  };\n  /**\n   * Formats the Timespan as a sentence in HTML\n   * \n   * @param {string=} tag HTML tag name to wrap each value\n   * @param {string=} emptyLabel the string to use when no values returned\n   * @return {string}\n   */\n\n\n  Timespan.prototype.toHTML = function (tag, emptyLabel) {\n    tag = tag || 'span';\n    var label = formatList(this);\n    var count = label.length;\n\n    if (!count) {\n      emptyLabel = emptyLabel || LABEL_NOW;\n      return emptyLabel ? '<' + tag + '>' + emptyLabel + '</' + tag + '>' : emptyLabel;\n    }\n\n    for (var i = 0; i < count; i++) {\n      // wrap each unit in tag\n      label[i] = '<' + tag + '>' + label[i] + '</' + tag + '>';\n    }\n\n    if (count === 1) {\n      return label[0];\n    }\n\n    var last = LABEL_LAST + label.pop();\n    return label.join(LABEL_DELIM) + last;\n  };\n  /**\n   * Applies the Timespan to the given date\n   * \n   * @param {Date=} date the date to which the timespan is added.\n   * @return {Date}\n   */\n\n\n  Timespan.prototype.addTo = function (date) {\n    return addToDate(this, date);\n  };\n  /**\n   * Formats the entries as English labels\n   * \n   * @private\n   * @param {Timespan} ts\n   * @return {Array}\n   */\n\n\n  formatList = function (ts) {\n    var list = [];\n    var value = ts.millennia;\n\n    if (value) {\n      list.push(formatter(value, LABEL_MILLENNIA));\n    }\n\n    value = ts.centuries;\n\n    if (value) {\n      list.push(formatter(value, LABEL_CENTURIES));\n    }\n\n    value = ts.decades;\n\n    if (value) {\n      list.push(formatter(value, LABEL_DECADES));\n    }\n\n    value = ts.years;\n\n    if (value) {\n      list.push(formatter(value, LABEL_YEARS));\n    }\n\n    value = ts.months;\n\n    if (value) {\n      list.push(formatter(value, LABEL_MONTHS));\n    }\n\n    value = ts.weeks;\n\n    if (value) {\n      list.push(formatter(value, LABEL_WEEKS));\n    }\n\n    value = ts.days;\n\n    if (value) {\n      list.push(formatter(value, LABEL_DAYS));\n    }\n\n    value = ts.hours;\n\n    if (value) {\n      list.push(formatter(value, LABEL_HOURS));\n    }\n\n    value = ts.minutes;\n\n    if (value) {\n      list.push(formatter(value, LABEL_MINUTES));\n    }\n\n    value = ts.seconds;\n\n    if (value) {\n      list.push(formatter(value, LABEL_SECONDS));\n    }\n\n    value = ts.milliseconds;\n\n    if (value) {\n      list.push(formatter(value, LABEL_MILLISECONDS));\n    }\n\n    return list;\n  };\n  /**\n   * Borrow any underflow units, carry any overflow units\n   * \n   * @private\n   * @param {Timespan} ts\n   * @param {string} toUnit\n   */\n\n\n  function rippleRounded(ts, toUnit) {\n    switch (toUnit) {\n      case 'seconds':\n        if (ts.seconds !== SECONDS_PER_MINUTE || isNaN(ts.minutes)) {\n          return;\n        } // ripple seconds up to minutes\n\n\n        ts.minutes++;\n        ts.seconds = 0;\n\n      /* falls through */\n\n      case 'minutes':\n        if (ts.minutes !== MINUTES_PER_HOUR || isNaN(ts.hours)) {\n          return;\n        } // ripple minutes up to hours\n\n\n        ts.hours++;\n        ts.minutes = 0;\n\n      /* falls through */\n\n      case 'hours':\n        if (ts.hours !== HOURS_PER_DAY || isNaN(ts.days)) {\n          return;\n        } // ripple hours up to days\n\n\n        ts.days++;\n        ts.hours = 0;\n\n      /* falls through */\n\n      case 'days':\n        if (ts.days !== DAYS_PER_WEEK || isNaN(ts.weeks)) {\n          return;\n        } // ripple days up to weeks\n\n\n        ts.weeks++;\n        ts.days = 0;\n\n      /* falls through */\n\n      case 'weeks':\n        if (ts.weeks !== daysPerMonth(ts.refMonth) / DAYS_PER_WEEK || isNaN(ts.months)) {\n          return;\n        } // ripple weeks up to months\n\n\n        ts.months++;\n        ts.weeks = 0;\n\n      /* falls through */\n\n      case 'months':\n        if (ts.months !== MONTHS_PER_YEAR || isNaN(ts.years)) {\n          return;\n        } // ripple months up to years\n\n\n        ts.years++;\n        ts.months = 0;\n\n      /* falls through */\n\n      case 'years':\n        if (ts.years !== YEARS_PER_DECADE || isNaN(ts.decades)) {\n          return;\n        } // ripple years up to decades\n\n\n        ts.decades++;\n        ts.years = 0;\n\n      /* falls through */\n\n      case 'decades':\n        if (ts.decades !== DECADES_PER_CENTURY || isNaN(ts.centuries)) {\n          return;\n        } // ripple decades up to centuries\n\n\n        ts.centuries++;\n        ts.decades = 0;\n\n      /* falls through */\n\n      case 'centuries':\n        if (ts.centuries !== CENTURIES_PER_MILLENNIUM || isNaN(ts.millennia)) {\n          return;\n        } // ripple centuries up to millennia\n\n\n        ts.millennia++;\n        ts.centuries = 0;\n\n      /* falls through */\n    }\n  }\n  /**\n   * Ripple up partial units one place\n   * \n   * @private\n   * @param {Timespan} ts timespan\n   * @param {number} frac accumulated fractional value\n   * @param {string} fromUnit source unit name\n   * @param {string} toUnit target unit name\n   * @param {number} conversion multiplier between units\n   * @param {number} digits max number of decimal digits to output\n   * @return {number} new fractional value\n   */\n\n\n  function fraction(ts, frac, fromUnit, toUnit, conversion, digits) {\n    if (ts[fromUnit] >= 0) {\n      frac += ts[fromUnit];\n      delete ts[fromUnit];\n    }\n\n    frac /= conversion;\n\n    if (frac + 1 <= 1) {\n      // drop if below machine epsilon\n      return 0;\n    }\n\n    if (ts[toUnit] >= 0) {\n      // ensure does not have more than specified number of digits\n      ts[toUnit] = +(ts[toUnit] + frac).toFixed(digits);\n      rippleRounded(ts, toUnit);\n      return 0;\n    }\n\n    return frac;\n  }\n  /**\n   * Ripple up partial units to next existing\n   * \n   * @private\n   * @param {Timespan} ts\n   * @param {number} digits max number of decimal digits to output\n   */\n\n\n  function fractional(ts, digits) {\n    var frac = fraction(ts, 0, 'milliseconds', 'seconds', MILLISECONDS_PER_SECOND, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'seconds', 'minutes', SECONDS_PER_MINUTE, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'minutes', 'hours', MINUTES_PER_HOUR, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'hours', 'days', HOURS_PER_DAY, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'days', 'weeks', DAYS_PER_WEEK, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'weeks', 'months', daysPerMonth(ts.refMonth) / DAYS_PER_WEEK, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'months', 'years', daysPerYear(ts.refMonth) / daysPerMonth(ts.refMonth), digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'years', 'decades', YEARS_PER_DECADE, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'decades', 'centuries', DECADES_PER_CENTURY, digits);\n\n    if (!frac) {\n      return;\n    }\n\n    frac = fraction(ts, frac, 'centuries', 'millennia', CENTURIES_PER_MILLENNIUM, digits); // should never reach this with remaining fractional value\n\n    if (frac) {\n      throw new Error('Fractional unit overflow');\n    }\n  }\n  /**\n   * Borrow any underflow units, carry any overflow units\n   * \n   * @private\n   * @param {Timespan} ts\n   */\n\n\n  function ripple(ts) {\n    var x;\n\n    if (ts.milliseconds < 0) {\n      // ripple seconds down to milliseconds\n      x = ceil(-ts.milliseconds / MILLISECONDS_PER_SECOND);\n      ts.seconds -= x;\n      ts.milliseconds += x * MILLISECONDS_PER_SECOND;\n    } else if (ts.milliseconds >= MILLISECONDS_PER_SECOND) {\n      // ripple milliseconds up to seconds\n      ts.seconds += floor(ts.milliseconds / MILLISECONDS_PER_SECOND);\n      ts.milliseconds %= MILLISECONDS_PER_SECOND;\n    }\n\n    if (ts.seconds < 0) {\n      // ripple minutes down to seconds\n      x = ceil(-ts.seconds / SECONDS_PER_MINUTE);\n      ts.minutes -= x;\n      ts.seconds += x * SECONDS_PER_MINUTE;\n    } else if (ts.seconds >= SECONDS_PER_MINUTE) {\n      // ripple seconds up to minutes\n      ts.minutes += floor(ts.seconds / SECONDS_PER_MINUTE);\n      ts.seconds %= SECONDS_PER_MINUTE;\n    }\n\n    if (ts.minutes < 0) {\n      // ripple hours down to minutes\n      x = ceil(-ts.minutes / MINUTES_PER_HOUR);\n      ts.hours -= x;\n      ts.minutes += x * MINUTES_PER_HOUR;\n    } else if (ts.minutes >= MINUTES_PER_HOUR) {\n      // ripple minutes up to hours\n      ts.hours += floor(ts.minutes / MINUTES_PER_HOUR);\n      ts.minutes %= MINUTES_PER_HOUR;\n    }\n\n    if (ts.hours < 0) {\n      // ripple days down to hours\n      x = ceil(-ts.hours / HOURS_PER_DAY);\n      ts.days -= x;\n      ts.hours += x * HOURS_PER_DAY;\n    } else if (ts.hours >= HOURS_PER_DAY) {\n      // ripple hours up to days\n      ts.days += floor(ts.hours / HOURS_PER_DAY);\n      ts.hours %= HOURS_PER_DAY;\n    }\n\n    while (ts.days < 0) {\n      // NOTE: never actually seen this loop more than once\n      // ripple months down to days\n      ts.months--;\n      ts.days += borrowMonths(ts.refMonth, 1);\n    } // weeks is always zero here\n\n\n    if (ts.days >= DAYS_PER_WEEK) {\n      // ripple days up to weeks\n      ts.weeks += floor(ts.days / DAYS_PER_WEEK);\n      ts.days %= DAYS_PER_WEEK;\n    }\n\n    if (ts.months < 0) {\n      // ripple years down to months\n      x = ceil(-ts.months / MONTHS_PER_YEAR);\n      ts.years -= x;\n      ts.months += x * MONTHS_PER_YEAR;\n    } else if (ts.months >= MONTHS_PER_YEAR) {\n      // ripple months up to years\n      ts.years += floor(ts.months / MONTHS_PER_YEAR);\n      ts.months %= MONTHS_PER_YEAR;\n    } // years is always non-negative here\n    // decades, centuries and millennia are always zero here\n\n\n    if (ts.years >= YEARS_PER_DECADE) {\n      // ripple years up to decades\n      ts.decades += floor(ts.years / YEARS_PER_DECADE);\n      ts.years %= YEARS_PER_DECADE;\n\n      if (ts.decades >= DECADES_PER_CENTURY) {\n        // ripple decades up to centuries\n        ts.centuries += floor(ts.decades / DECADES_PER_CENTURY);\n        ts.decades %= DECADES_PER_CENTURY;\n\n        if (ts.centuries >= CENTURIES_PER_MILLENNIUM) {\n          // ripple centuries up to millennia\n          ts.millennia += floor(ts.centuries / CENTURIES_PER_MILLENNIUM);\n          ts.centuries %= CENTURIES_PER_MILLENNIUM;\n        }\n      }\n    }\n  }\n  /**\n   * Remove any units not requested\n   * \n   * @private\n   * @param {Timespan} ts\n   * @param {number} units the units to populate\n   * @param {number} max number of labels to output\n   * @param {number} digits max number of decimal digits to output\n   */\n\n\n  function pruneUnits(ts, units, max, digits) {\n    var count = 0; // Calc from largest unit to smallest to prevent underflow\n\n    if (!(units & MILLENNIA) || count >= max) {\n      // ripple millennia down to centuries\n      ts.centuries += ts.millennia * CENTURIES_PER_MILLENNIUM;\n      delete ts.millennia;\n    } else if (ts.millennia) {\n      count++;\n    }\n\n    if (!(units & CENTURIES) || count >= max) {\n      // ripple centuries down to decades\n      ts.decades += ts.centuries * DECADES_PER_CENTURY;\n      delete ts.centuries;\n    } else if (ts.centuries) {\n      count++;\n    }\n\n    if (!(units & DECADES) || count >= max) {\n      // ripple decades down to years\n      ts.years += ts.decades * YEARS_PER_DECADE;\n      delete ts.decades;\n    } else if (ts.decades) {\n      count++;\n    }\n\n    if (!(units & YEARS) || count >= max) {\n      // ripple years down to months\n      ts.months += ts.years * MONTHS_PER_YEAR;\n      delete ts.years;\n    } else if (ts.years) {\n      count++;\n    }\n\n    if (!(units & MONTHS) || count >= max) {\n      // ripple months down to days\n      if (ts.months) {\n        ts.days += borrowMonths(ts.refMonth, ts.months);\n      }\n\n      delete ts.months;\n\n      if (ts.days >= DAYS_PER_WEEK) {\n        // ripple day overflow back up to weeks\n        ts.weeks += floor(ts.days / DAYS_PER_WEEK);\n        ts.days %= DAYS_PER_WEEK;\n      }\n    } else if (ts.months) {\n      count++;\n    }\n\n    if (!(units & WEEKS) || count >= max) {\n      // ripple weeks down to days\n      ts.days += ts.weeks * DAYS_PER_WEEK;\n      delete ts.weeks;\n    } else if (ts.weeks) {\n      count++;\n    }\n\n    if (!(units & DAYS) || count >= max) {\n      //ripple days down to hours\n      ts.hours += ts.days * HOURS_PER_DAY;\n      delete ts.days;\n    } else if (ts.days) {\n      count++;\n    }\n\n    if (!(units & HOURS) || count >= max) {\n      // ripple hours down to minutes\n      ts.minutes += ts.hours * MINUTES_PER_HOUR;\n      delete ts.hours;\n    } else if (ts.hours) {\n      count++;\n    }\n\n    if (!(units & MINUTES) || count >= max) {\n      // ripple minutes down to seconds\n      ts.seconds += ts.minutes * SECONDS_PER_MINUTE;\n      delete ts.minutes;\n    } else if (ts.minutes) {\n      count++;\n    }\n\n    if (!(units & SECONDS) || count >= max) {\n      // ripple seconds down to milliseconds\n      ts.milliseconds += ts.seconds * MILLISECONDS_PER_SECOND;\n      delete ts.seconds;\n    } else if (ts.seconds) {\n      count++;\n    } // nothing to ripple milliseconds down to\n    // so ripple back up to smallest existing unit as a fractional value\n\n\n    if (!(units & MILLISECONDS) || count >= max) {\n      fractional(ts, digits);\n    }\n  }\n  /**\n   * Populates the Timespan object\n   * \n   * @private\n   * @param {Timespan} ts\n   * @param {?Date} start the starting date\n   * @param {?Date} end the ending date\n   * @param {number} units the units to populate\n   * @param {number} max number of labels to output\n   * @param {number} digits max number of decimal digits to output\n   */\n\n\n  function populate(ts, start, end, units, max, digits) {\n    var now = new Date();\n    ts.start = start = start || now;\n    ts.end = end = end || now;\n    ts.units = units;\n    ts.value = end.getTime() - start.getTime();\n\n    if (ts.value < 0) {\n      // swap if reversed\n      var tmp = end;\n      end = start;\n      start = tmp;\n    } // reference month for determining days in month\n\n\n    ts.refMonth = new Date(start.getFullYear(), start.getMonth(), 15, 12, 0, 0);\n\n    try {\n      // reset to initial deltas\n      ts.millennia = 0;\n      ts.centuries = 0;\n      ts.decades = 0;\n      ts.years = end.getFullYear() - start.getFullYear();\n      ts.months = end.getMonth() - start.getMonth();\n      ts.weeks = 0;\n      ts.days = end.getDate() - start.getDate();\n      ts.hours = end.getHours() - start.getHours();\n      ts.minutes = end.getMinutes() - start.getMinutes();\n      ts.seconds = end.getSeconds() - start.getSeconds();\n      ts.milliseconds = end.getMilliseconds() - start.getMilliseconds();\n      ripple(ts);\n      pruneUnits(ts, units, max, digits);\n    } finally {\n      delete ts.refMonth;\n    }\n\n    return ts;\n  }\n  /**\n   * Determine an appropriate refresh rate based upon units\n   * \n   * @private\n   * @param {number} units the units to populate\n   * @return {number} milliseconds to delay\n   */\n\n\n  function getDelay(units) {\n    if (units & MILLISECONDS) {\n      // refresh very quickly\n      return MILLISECONDS_PER_SECOND / 30; //30Hz\n    }\n\n    if (units & SECONDS) {\n      // refresh every second\n      return MILLISECONDS_PER_SECOND; //1Hz\n    }\n\n    if (units & MINUTES) {\n      // refresh every minute\n      return MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n    }\n\n    if (units & HOURS) {\n      // refresh hourly\n      return MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n    }\n\n    if (units & DAYS) {\n      // refresh daily\n      return MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;\n    } // refresh the rest weekly\n\n\n    return MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY * DAYS_PER_WEEK;\n  }\n  /**\n   * API entry point\n   * \n   * @public\n   * @param {Date|number|Timespan|null|function(Timespan,number)} start the starting date\n   * @param {Date|number|Timespan|null|function(Timespan,number)} end the ending date\n   * @param {number=} units the units to populate\n   * @param {number=} max number of labels to output\n   * @param {number=} digits max number of decimal digits to output\n   * @return {Timespan|number}\n   */\n\n\n  function countdown(start, end, units, max, digits) {\n    var callback; // ensure some units or use defaults\n\n    units = +units || DEFAULTS; // max must be positive\n\n    max = max > 0 ? max : NaN; // clamp digits to an integer between [0, 20]\n\n    digits = digits > 0 ? digits < 20 ? Math.round(digits) : 20 : 0; // ensure start date\n\n    var startTS = null;\n\n    if ('function' === typeof start) {\n      callback = start;\n      start = null;\n    } else if (!(start instanceof Date)) {\n      if (start !== null && isFinite(start)) {\n        start = new Date(+start);\n      } else {\n        if ('object' === typeof startTS) {\n          startTS =\n          /** @type{Timespan} */\n          start;\n        }\n\n        start = null;\n      }\n    } // ensure end date\n\n\n    var endTS = null;\n\n    if ('function' === typeof end) {\n      callback = end;\n      end = null;\n    } else if (!(end instanceof Date)) {\n      if (end !== null && isFinite(end)) {\n        end = new Date(+end);\n      } else {\n        if ('object' === typeof end) {\n          endTS =\n          /** @type{Timespan} */\n          end;\n        }\n\n        end = null;\n      }\n    } // must wait to interpret timespans until after resolving dates\n\n\n    if (startTS) {\n      start = addToDate(startTS, end);\n    }\n\n    if (endTS) {\n      end = addToDate(endTS, start);\n    }\n\n    if (!start && !end) {\n      // used for unit testing\n      return new Timespan();\n    }\n\n    if (!callback) {\n      return populate(new Timespan(),\n      /** @type{Date} */\n      start,\n      /** @type{Date} */\n      end,\n      /** @type{number} */\n      units,\n      /** @type{number} */\n      max,\n      /** @type{number} */\n      digits);\n    } // base delay off units\n\n\n    var delay = getDelay(units),\n        timerId,\n        fn = function () {\n      callback(populate(new Timespan(),\n      /** @type{Date} */\n      start,\n      /** @type{Date} */\n      end,\n      /** @type{number} */\n      units,\n      /** @type{number} */\n      max,\n      /** @type{number} */\n      digits), timerId);\n    };\n\n    fn();\n    return timerId = setInterval(fn, delay);\n  }\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n\n  countdown.MILLISECONDS = MILLISECONDS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.SECONDS = SECONDS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.MINUTES = MINUTES;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.HOURS = HOURS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.DAYS = DAYS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.WEEKS = WEEKS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.MONTHS = MONTHS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.YEARS = YEARS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.DECADES = DECADES;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.CENTURIES = CENTURIES;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.MILLENNIA = MILLENNIA;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.DEFAULTS = DEFAULTS;\n  /**\n   * @public\n   * @const\n   * @type {number}\n   */\n\n  countdown.ALL = MILLENNIA | CENTURIES | DECADES | YEARS | MONTHS | WEEKS | DAYS | HOURS | MINUTES | SECONDS | MILLISECONDS;\n  /**\n   * Customize the format settings.\n   * @public\n   * @param {Object} format settings object\n   */\n\n  var setFormat = countdown.setFormat = function (format) {\n    if (!format) {\n      return;\n    }\n\n    if ('singular' in format || 'plural' in format) {\n      var singular = format.singular || [];\n\n      if (singular.split) {\n        singular = singular.split('|');\n      }\n\n      var plural = format.plural || [];\n\n      if (plural.split) {\n        plural = plural.split('|');\n      }\n\n      for (var i = LABEL_MILLISECONDS; i <= LABEL_MILLENNIA; i++) {\n        // override any specified units\n        LABELS_SINGLUAR[i] = singular[i] || LABELS_SINGLUAR[i];\n        LABELS_PLURAL[i] = plural[i] || LABELS_PLURAL[i];\n      }\n    }\n\n    if ('string' === typeof format.last) {\n      LABEL_LAST = format.last;\n    }\n\n    if ('string' === typeof format.delim) {\n      LABEL_DELIM = format.delim;\n    }\n\n    if ('string' === typeof format.empty) {\n      LABEL_NOW = format.empty;\n    }\n\n    if ('function' === typeof format.formatNumber) {\n      formatNumber = format.formatNumber;\n    }\n\n    if ('function' === typeof format.formatter) {\n      formatter = format.formatter;\n    }\n  };\n  /**\n   * Revert to the default formatting.\n   * @public\n   */\n\n\n  var resetFormat = countdown.resetFormat = function () {\n    LABELS_SINGLUAR = ' millisecond| second| minute| hour| day| week| month| year| decade| century| millennium'.split('|');\n    LABELS_PLURAL = ' milliseconds| seconds| minutes| hours| days| weeks| months| years| decades| centuries| millennia'.split('|');\n    LABEL_LAST = ' and ';\n    LABEL_DELIM = ', ';\n    LABEL_NOW = '';\n\n    formatNumber = function (value) {\n      return value;\n    };\n\n    formatter = plurality;\n  };\n  /**\n   * Override the unit labels.\n   * @public\n   * @param {string|Array=} singular a pipe ('|') delimited list of singular unit name overrides\n   * @param {string|Array=} plural a pipe ('|') delimited list of plural unit name overrides\n   * @param {string=} last a delimiter before the last unit (default: ' and ')\n   * @param {string=} delim a delimiter to use between all other units (default: ', ')\n   * @param {string=} empty a label to use when all units are zero (default: '')\n   * @param {function(number):string=} formatNumber a function which formats numbers as a string\n   * @param {function(number,number):string=} formatter a function which formats a number/unit pair as a string\n   * @deprecated since version 2.6.0\n   */\n\n\n  countdown.setLabels = function (singular, plural, last, delim, empty, formatNumber, formatter) {\n    setFormat({\n      singular: singular,\n      plural: plural,\n      last: last,\n      delim: delim,\n      empty: empty,\n      formatNumber: formatNumber,\n      formatter: formatter\n    });\n  };\n  /**\n   * Revert to the default unit labels.\n   * @public\n   * @deprecated since version 2.6.0\n   */\n\n\n  countdown.resetLabels = resetFormat;\n  resetFormat();\n\n  if (module && module.exports) {\n    module.exports = countdown;\n  } else if (typeof window.define === 'function' && typeof window.define.amd !== 'undefined') {\n    window.define('countdown', [], function () {\n      return countdown;\n    });\n  }\n\n  return countdown;\n}(module);","map":null,"metadata":{},"sourceType":"script"}