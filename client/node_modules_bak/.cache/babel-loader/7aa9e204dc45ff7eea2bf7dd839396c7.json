{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nexport default function AlignmentPattern(posX, posY, estimatedModuleSize) {\n  this.x = posX;\n  this.y = posY;\n  this.count = 1;\n  this.estimatedModuleSize = estimatedModuleSize;\n}\nObject.defineProperty(AlignmentPattern.prototype, \"X\", {\n  get: function () {\n    return Math.floor(this.x);\n  }\n});\nObject.defineProperty(AlignmentPattern.prototype, \"Y\", {\n  get: function () {\n    return Math.floor(this.y);\n  }\n});\n\nAlignmentPattern.prototype.incrementCount = function () {\n  this.count++;\n};\n\nAlignmentPattern.prototype.aboutEquals = function (moduleSize, i, j) {\n  if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n    var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n    return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n  }\n\n  return false;\n};\n\nexport function AlignmentPatternFinder(image, startX, startY, width, height, moduleSize, resultPointCallback) {\n  this.image = image;\n  this.possibleCenters = [];\n  this.startX = startX;\n  this.startY = startY;\n  this.width = width;\n  this.height = height;\n  this.moduleSize = moduleSize;\n  this.crossCheckStateCount = [0, 0, 0];\n  this.resultPointCallback = resultPointCallback;\n}\n\nAlignmentPatternFinder.prototype.centerFromEnd = function (stateCount, end) {\n  return end - stateCount[2] - stateCount[1] / 2.0;\n};\n\nAlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {\n  var moduleSize = this.moduleSize;\n  var maxVariance = moduleSize / 2.0;\n\n  for (var i = 0; i < 3; i++) {\n    if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nAlignmentPatternFinder.prototype.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n  var image = this.image;\n  var maxI = image.height;\n  var stateCount = this.crossCheckStateCount;\n  stateCount[0] = 0;\n  stateCount[1] = 0;\n  stateCount[2] = 0; // Start counting up from center\n\n  var i = startI;\n\n  while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {\n    stateCount[1]++;\n    i--;\n  } // If already too many modules in this state or ran off the edge:\n\n\n  if (i < 0 || stateCount[1] > maxCount) {\n    return NaN;\n  }\n\n  while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {\n    stateCount[0]++;\n    i--;\n  }\n\n  if (stateCount[0] > maxCount) {\n    return NaN;\n  } // Now also count down from center\n\n\n  i = startI + 1;\n\n  while (i < maxI && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {\n    stateCount[1]++;\n    i++;\n  }\n\n  if (i == maxI || stateCount[1] > maxCount) {\n    return NaN;\n  }\n\n  while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[2] <= maxCount) {\n    stateCount[2]++;\n    i++;\n  }\n\n  if (stateCount[2] > maxCount) {\n    return NaN;\n  }\n\n  var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n\n  if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n    return NaN;\n  }\n\n  return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n};\n\nAlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i, j) {\n  var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n  var centerJ = this.centerFromEnd(stateCount, j);\n  var centerI = this.crossCheckVertical(i, Math.floor(centerJ), 2 * stateCount[1], stateCountTotal);\n\n  if (!isNaN(centerI)) {\n    var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n    var max = this.possibleCenters.length;\n\n    for (var index = 0; index < max; index++) {\n      var center = this.possibleCenters[index]; // Look for about the same center and module size:\n\n      if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n        return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n      }\n    } // Hadn't found this before; save it\n\n\n    var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n    this.possibleCenters.push(point);\n\n    if (this.resultPointCallback != null) {\n      this.resultPointCallback.foundPossibleResultPoint(point);\n    }\n  }\n\n  return null;\n};\n\nAlignmentPatternFinder.prototype.find = function () {\n  var image = this.image;\n  var startX = this.startX;\n  var height = this.height;\n  var maxJ = startX + this.width;\n  var middleI = this.startY + (height >> 1); // We are looking for black/white/black modules in 1:1:1 ratio;\n  // this tracks the number of black/white/black modules seen so far\n\n  var stateCount = [0, 0, 0];\n\n  for (var iGen = 0; iGen < height; iGen++) {\n    // Search from middle outwards\n    var i = middleI + ((iGen & 0x01) == 0 ? iGen + 1 >> 1 : -(iGen + 1 >> 1));\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0;\n    var j = startX; // Burn off leading white pixels before anything else; if we start in the middle of\n    // a white run, it doesn't make sense to count its length, since we don't know if the\n    // white run continued to the left of the start point\n\n    while (j < maxJ && !image.data[j + image.width * i]) {\n      j++;\n    }\n\n    var currentState = 0;\n\n    while (j < maxJ) {\n      if (image.data[j + i * image.width]) {\n        // Black pixel\n        if (currentState == 1) {\n          // Counting black pixels\n          stateCount[currentState]++;\n        } else {\n          // Counting white pixels\n          if (currentState == 2) {\n            // A winner?\n            if (this.foundPatternCross(stateCount)) {\n              // Yes\n              var confirmed = this.handlePossibleCenter(stateCount, i, j);\n\n              if (confirmed != null) {\n                return confirmed;\n              }\n            }\n\n            stateCount[0] = stateCount[2];\n            stateCount[1] = 1;\n            stateCount[2] = 0;\n            currentState = 1;\n          } else {\n            stateCount[++currentState]++;\n          }\n        }\n      } else {\n        // White pixel\n        if (currentState == 1) {\n          // Counting black pixels\n          currentState++;\n        }\n\n        stateCount[currentState]++;\n      }\n\n      j++;\n    }\n\n    if (this.foundPatternCross(stateCount)) {\n      var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n\n      if (confirmed != null) {\n        return confirmed;\n      }\n    }\n  } // Hmm, nothing we saw was observed and confirmed twice. If we had\n  // any guess at all, return it.\n\n\n  if (!(this.possibleCenters.length == 0)) {\n    return this.possibleCenters[0];\n  }\n\n  throw \"Couldn't find enough alignment patterns\";\n};","map":null,"metadata":{},"sourceType":"module"}