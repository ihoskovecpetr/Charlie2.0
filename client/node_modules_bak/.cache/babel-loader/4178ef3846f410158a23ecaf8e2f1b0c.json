{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nexport default function DataBlock(numDataCodewords, codewords) {\n  this.numDataCodewords = numDataCodewords;\n  this.codewords = codewords;\n}\n\nDataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {\n  if (rawCodewords.length != version.totalCodewords) {\n    throw \"ArgumentException\";\n  } // Figure out the number and size of data blocks used by this version and\n  // error correction level\n\n\n  var ecBlocks = version.getECBlocksForLevel(ecLevel); // First count the total number of data blocks\n\n  var totalBlocks = 0;\n  var ecBlockArray = ecBlocks.getECBlocks();\n\n  for (var i = 0; i < ecBlockArray.length; i++) {\n    totalBlocks += ecBlockArray[i].count;\n  } // Now establish DataBlocks of the appropriate size and number of data codewords\n\n\n  var result = new Array(totalBlocks);\n  var numResultBlocks = 0;\n\n  for (var j = 0; j < ecBlockArray.length; j++) {\n    var ecBlock = ecBlockArray[j];\n\n    for (var i = 0; i < ecBlock.count; i++) {\n      var numDataCodewords = ecBlock.dataCodewords;\n      var numBlockCodewords = ecBlocks.ecCodewordsPerBlock + numDataCodewords;\n      result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords));\n    }\n  } // All blocks have the same amount of data, except that the last n\n  // (where n may be 0) have 1 more byte. Figure out where these start.\n\n\n  var shorterBlocksTotalCodewords = result[0].codewords.length;\n  var longerBlocksStartAt = result.length - 1;\n\n  while (longerBlocksStartAt >= 0) {\n    var numCodewords = result[longerBlocksStartAt].codewords.length;\n\n    if (numCodewords == shorterBlocksTotalCodewords) {\n      break;\n    }\n\n    longerBlocksStartAt--;\n  }\n\n  longerBlocksStartAt++;\n  var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ecCodewordsPerBlock; // The last elements of result may be 1 element longer;\n  // first fill out as many elements as all of them have\n\n  var rawCodewordsOffset = 0;\n\n  for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n    for (var j = 0; j < numResultBlocks; j++) {\n      result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n    }\n  } // Fill out the last data block in the longer ones\n\n\n  for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {\n    result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n  } // Now add in error correction blocks\n\n\n  var max = result[0].codewords.length;\n\n  for (var i = shorterBlocksNumDataCodewords; i < max; i++) {\n    for (var j = 0; j < numResultBlocks; j++) {\n      var iOffset = j < longerBlocksStartAt ? i : i + 1;\n      result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n    }\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}