{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport BitMatrix from './bitmat';\nvar GridSampler = {};\n\nGridSampler.checkAndNudgePoints = function (image, points) {\n  var width = image.width;\n  var height = image.height; // Check and nudge points from start until we see some that are OK:\n\n  var nudged = true;\n\n  for (var offset = 0; offset < points.length && nudged; offset += 2) {\n    var x = Math.floor(points[offset]);\n    var y = Math.floor(points[offset + 1]);\n\n    if (x < -1 || x > width || y < -1 || y > height) {\n      throw \"Error.checkAndNudgePoints \";\n    }\n\n    nudged = false;\n\n    if (x == -1) {\n      points[offset] = 0.0;\n      nudged = true;\n    } else if (x == width) {\n      points[offset] = width - 1;\n      nudged = true;\n    }\n\n    if (y == -1) {\n      points[offset + 1] = 0.0;\n      nudged = true;\n    } else if (y == height) {\n      points[offset + 1] = height - 1;\n      nudged = true;\n    }\n  } // Check and nudge points from end:\n\n\n  nudged = true;\n\n  for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n    var x = Math.floor(points[offset]);\n    var y = Math.floor(points[offset + 1]);\n\n    if (x < -1 || x > width || y < -1 || y > height) {\n      throw \"Error.checkAndNudgePoints \";\n    }\n\n    nudged = false;\n\n    if (x == -1) {\n      points[offset] = 0.0;\n      nudged = true;\n    } else if (x == width) {\n      points[offset] = width - 1;\n      nudged = true;\n    }\n\n    if (y == -1) {\n      points[offset + 1] = 0.0;\n      nudged = true;\n    } else if (y == height) {\n      points[offset + 1] = height - 1;\n      nudged = true;\n    }\n  }\n};\n\nGridSampler.sampleGrid3 = function (image, dimension, transform) {\n  var bits = new BitMatrix(dimension);\n  var points = new Array(dimension << 1);\n\n  for (var y = 0; y < dimension; y++) {\n    var max = points.length;\n    var iValue = y + 0.5;\n\n    for (var x = 0; x < max; x += 2) {\n      points[x] = (x >> 1) + 0.5;\n      points[x + 1] = iValue;\n    }\n\n    transform.transformPoints1(points); // Quick check to see if points transformed to something inside the image\n    // sufficient to check the endpoints\n\n    GridSampler.checkAndNudgePoints(image, points);\n\n    try {\n      for (var x = 0; x < max; x += 2) {\n        var bit = image.data[Math.floor(points[x]) + image.width * Math.floor(points[x + 1])];\n        if (bit) bits.set_Renamed(x >> 1, y);\n      }\n    } catch (aioobe) {\n      // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n      // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n      // whose endpoints are in bounds, but others are not. There is probably some mathematical\n      // way to detect this about the transformation that I don't know yet.\n      // This results in an ugly runtime exception despite our clever checks above -- can't have\n      // that. We could check each point's coordinates but that feels duplicative. We settle for\n      // catching and wrapping ArrayIndexOutOfBoundsException.\n      throw \"Error.checkAndNudgePoints\";\n    }\n  }\n\n  return bits;\n};\n\nexport default GridSampler;","map":null,"metadata":{},"sourceType":"module"}