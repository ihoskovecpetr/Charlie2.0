{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport FormatInformation from './formatinf';\nimport Version from './version';\nimport DataMask from './datamask';\nexport default function BitMatrixParser(bitMatrix) {\n  var dimension = bitMatrix.Dimension;\n\n  if (dimension < 21 || (dimension & 0x03) != 1) {\n    throw \"Error BitMatrixParser\";\n  }\n\n  this.bitMatrix = bitMatrix;\n  this.parsedVersion = null;\n  this.parsedFormatInfo = null;\n}\n\nBitMatrixParser.prototype.copyBit = function (i, j, versionBits) {\n  return this.bitMatrix.get_Renamed(i, j) ? versionBits << 1 | 0x1 : versionBits << 1;\n};\n\nBitMatrixParser.prototype.readFormatInformation = function () {\n  if (this.parsedFormatInfo != null) {\n    return this.parsedFormatInfo;\n  } // Read top-left format info bits\n\n\n  var formatInfoBits = 0;\n\n  for (var i = 0; i < 6; i++) {\n    formatInfoBits = this.copyBit(i, 8, formatInfoBits);\n  } // .. and skip a bit in the timing pattern ...\n\n\n  formatInfoBits = this.copyBit(7, 8, formatInfoBits);\n  formatInfoBits = this.copyBit(8, 8, formatInfoBits);\n  formatInfoBits = this.copyBit(8, 7, formatInfoBits); // .. and skip a bit in the timing pattern ...\n\n  for (var j = 5; j >= 0; j--) {\n    formatInfoBits = this.copyBit(8, j, formatInfoBits);\n  }\n\n  this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);\n\n  if (this.parsedFormatInfo != null) {\n    return this.parsedFormatInfo;\n  } // Hmm, failed. Try the top-right/bottom-left pattern\n\n\n  var dimension = this.bitMatrix.Dimension;\n  formatInfoBits = 0;\n  var iMin = dimension - 8;\n\n  for (var i = dimension - 1; i >= iMin; i--) {\n    formatInfoBits = this.copyBit(i, 8, formatInfoBits);\n  }\n\n  for (var j = dimension - 7; j < dimension; j++) {\n    formatInfoBits = this.copyBit(8, j, formatInfoBits);\n  }\n\n  this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);\n\n  if (this.parsedFormatInfo != null) {\n    return this.parsedFormatInfo;\n  }\n\n  throw \"Error readFormatInformation\";\n};\n\nBitMatrixParser.prototype.readVersion = function () {\n  if (this.parsedVersion != null) {\n    return this.parsedVersion;\n  }\n\n  var dimension = this.bitMatrix.Dimension;\n  var provisionalVersion = dimension - 17 >> 2;\n\n  if (provisionalVersion <= 6) {\n    return Version.getVersionForNumber(provisionalVersion);\n  } // Read top-right version info: 3 wide by 6 tall\n\n\n  var versionBits = 0;\n  var ijMin = dimension - 11;\n\n  for (var j = 5; j >= 0; j--) {\n    for (var i = dimension - 9; i >= ijMin; i--) {\n      versionBits = this.copyBit(i, j, versionBits);\n    }\n  }\n\n  this.parsedVersion = Version.decodeVersionInformation(versionBits);\n\n  if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {\n    return this.parsedVersion;\n  } // Hmm, failed. Try bottom left: 6 wide by 3 tall\n\n\n  versionBits = 0;\n\n  for (var i = 5; i >= 0; i--) {\n    for (var j = dimension - 9; j >= ijMin; j--) {\n      versionBits = this.copyBit(i, j, versionBits);\n    }\n  }\n\n  this.parsedVersion = Version.decodeVersionInformation(versionBits);\n\n  if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {\n    return this.parsedVersion;\n  }\n\n  throw \"Error readVersion\";\n};\n\nBitMatrixParser.prototype.readCodewords = function () {\n  var formatInfo = this.readFormatInformation();\n  var version = this.readVersion(); // Get the data mask for the format used in this QR Code. This will exclude\n  // some bits from reading as we wind through the bit matrix.\n\n  var dataMask = DataMask.forReference(formatInfo.dataMask);\n  var dimension = this.bitMatrix.Dimension;\n  dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  var functionPattern = version.buildFunctionPattern();\n  var readingUp = true;\n  var result = new Array(version.totalCodewords);\n  var resultOffset = 0;\n  var currentByte = 0;\n  var bitsRead = 0; // Read columns in pairs, from right to left\n\n  for (var j = dimension - 1; j > 0; j -= 2) {\n    if (j == 6) {\n      // Skip whole column with vertical alignment pattern;\n      // saves time and makes the other code proceed more cleanly\n      j--;\n    } // Read alternatingly from bottom to top then top to bottom\n\n\n    for (var count = 0; count < dimension; count++) {\n      var i = readingUp ? dimension - 1 - count : count;\n\n      for (var col = 0; col < 2; col++) {\n        // Ignore bits covered by the function pattern\n        if (!functionPattern.get_Renamed(j - col, i)) {\n          // Read a bit\n          bitsRead++;\n          currentByte <<= 1;\n\n          if (this.bitMatrix.get_Renamed(j - col, i)) {\n            currentByte |= 1;\n          } // If we've made a whole byte, save it off\n\n\n          if (bitsRead == 8) {\n            result[resultOffset++] = currentByte;\n            bitsRead = 0;\n            currentByte = 0;\n          }\n        }\n      }\n    }\n\n    readingUp ^= true; // readingUp = !readingUp; // switch directions\n  }\n\n  if (resultOffset != version.totalCodewords) {\n    throw \"Error readCodewords\";\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}