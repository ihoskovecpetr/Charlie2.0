{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar MIN_SKIP = 3;\nvar MAX_MODULES = 57;\nvar INTEGER_MATH_SHIFT = 8;\nvar CENTER_QUORUM = 2;\n\nfunction orderBestPatterns(patterns) {\n  function distance(pattern1, pattern2) {\n    var xDiff = pattern1.X - pattern2.X;\n    var yDiff = pattern1.Y - pattern2.Y;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n  } /// <summary> Returns the z component of the cross product between vectors BC and BA.</summary>\n\n\n  function crossProductZ(pointA, pointB, pointC) {\n    var bX = pointB.x;\n    var bY = pointB.y;\n    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n  } // Find distances between pattern centers\n\n\n  var zeroOneDistance = distance(patterns[0], patterns[1]);\n  var oneTwoDistance = distance(patterns[1], patterns[2]);\n  var zeroTwoDistance = distance(patterns[0], patterns[2]);\n  var pointA, pointB, pointC; // Assume one closest to other two is B; A and C will just be guesses at first\n\n  if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n    pointB = patterns[0];\n    pointA = patterns[1];\n    pointC = patterns[2];\n  } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n    pointB = patterns[1];\n    pointA = patterns[0];\n    pointC = patterns[2];\n  } else {\n    pointB = patterns[2];\n    pointA = patterns[0];\n    pointC = patterns[1];\n  } // Use cross product to figure out whether A and C are correct or flipped.\n  // This asks whether BC x BA has a positive z component, which is the arrangement\n  // we want for A, B, C. If it's negative, then we've got it flipped around and\n  // should swap A and C.\n\n\n  if (crossProductZ(pointA, pointB, pointC) < 0.0) {\n    var temp = pointA;\n    pointA = pointC;\n    pointC = temp;\n  }\n\n  patterns[0] = pointA;\n  patterns[1] = pointB;\n  patterns[2] = pointC;\n}\n\nfunction FinderPattern(posX, posY, estimatedModuleSize) {\n  this.x = posX;\n  this.y = posY;\n  this.count = 1;\n  this.estimatedModuleSize = estimatedModuleSize;\n}\n\nObject.defineProperty(FinderPattern.prototype, \"X\", {\n  get: function () {\n    return this.x;\n  }\n});\nObject.defineProperty(FinderPattern.prototype, \"Y\", {\n  get: function () {\n    return this.y;\n  }\n});\n\nFinderPattern.prototype.incrementCount = function () {\n  this.count++;\n};\n\nFinderPattern.prototype.aboutEquals = function (moduleSize, i, j) {\n  if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n    var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n    return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n  }\n\n  return false;\n};\n\nfunction FinderPatternInfo(patternCenters) {\n  this.bottomLeft = patternCenters[0];\n  this.topLeft = patternCenters[1];\n  this.topRight = patternCenters[2];\n}\n\nexport function FinderPatternFinder() {\n  this.image = null;\n  this.possibleCenters = [];\n  this.hasSkipped = false;\n  this.crossCheckStateCount = [0, 0, 0, 0, 0];\n  this.resultPointCallback = null;\n}\nObject.defineProperty(FinderPatternFinder.prototype, \"CrossCheckStateCount\", {\n  get: function () {\n    this.crossCheckStateCount[0] = 0;\n    this.crossCheckStateCount[1] = 0;\n    this.crossCheckStateCount[2] = 0;\n    this.crossCheckStateCount[3] = 0;\n    this.crossCheckStateCount[4] = 0;\n    return this.crossCheckStateCount;\n  }\n});\n\nFinderPatternFinder.prototype.foundPatternCross = function (stateCount) {\n  var totalModuleSize = 0;\n\n  for (var i = 0; i < 5; i++) {\n    var count = stateCount[i];\n\n    if (count == 0) {\n      return false;\n    }\n\n    totalModuleSize += count;\n  }\n\n  if (totalModuleSize < 7) {\n    return false;\n  }\n\n  var moduleSize = Math.floor((totalModuleSize << INTEGER_MATH_SHIFT) / 7);\n  var maxVariance = Math.floor(moduleSize / 2); // Allow less than 50% variance from 1-1-3-1-1 proportions\n\n  return Math.abs(moduleSize - (stateCount[0] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << INTEGER_MATH_SHIFT)) < maxVariance;\n};\n\nFinderPatternFinder.prototype.centerFromEnd = function (stateCount, end) {\n  return end - stateCount[4] - stateCount[3] - stateCount[2] / 2.0;\n};\n\nFinderPatternFinder.prototype.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n  var image = this.image;\n  var maxI = image.height;\n  var stateCount = this.CrossCheckStateCount; // Start counting up from center\n\n  var i = startI;\n\n  while (i >= 0 && image.data[centerJ + i * image.width]) {\n    stateCount[2]++;\n    i--;\n  }\n\n  if (i < 0) {\n    return NaN;\n  }\n\n  while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {\n    stateCount[1]++;\n    i--;\n  } // If already too many modules in this state or ran off the edge:\n\n\n  if (i < 0 || stateCount[1] > maxCount) {\n    return NaN;\n  }\n\n  while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {\n    stateCount[0]++;\n    i--;\n  }\n\n  if (stateCount[0] > maxCount) {\n    return NaN;\n  } // Now also count down from center\n\n\n  i = startI + 1;\n\n  while (i < maxI && image.data[centerJ + i * image.width]) {\n    stateCount[2]++;\n    i++;\n  }\n\n  if (i == maxI) {\n    return NaN;\n  }\n\n  while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[3] < maxCount) {\n    stateCount[3]++;\n    i++;\n  }\n\n  if (i == maxI || stateCount[3] >= maxCount) {\n    return NaN;\n  }\n\n  while (i < maxI && image.data[centerJ + i * image.width] && stateCount[4] < maxCount) {\n    stateCount[4]++;\n    i++;\n  }\n\n  if (stateCount[4] >= maxCount) {\n    return NaN;\n  } // If we found a finder-pattern-like section, but its size is more than 40% different than\n  // the original, assume it's a false positive\n\n\n  var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n\n  if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n    return NaN;\n  }\n\n  return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n};\n\nFinderPatternFinder.prototype.crossCheckHorizontal = function (startJ, centerI, maxCount, originalStateCountTotal) {\n  var image = this.image;\n  var maxJ = image.width;\n  var stateCount = this.CrossCheckStateCount;\n  var j = startJ;\n\n  while (j >= 0 && image.data[j + centerI * image.width]) {\n    stateCount[2]++;\n    j--;\n  }\n\n  if (j < 0) {\n    return NaN;\n  }\n\n  while (j >= 0 && !image.data[j + centerI * image.width] && stateCount[1] <= maxCount) {\n    stateCount[1]++;\n    j--;\n  }\n\n  if (j < 0 || stateCount[1] > maxCount) {\n    return NaN;\n  }\n\n  while (j >= 0 && image.data[j + centerI * image.width] && stateCount[0] <= maxCount) {\n    stateCount[0]++;\n    j--;\n  }\n\n  if (stateCount[0] > maxCount) {\n    return NaN;\n  }\n\n  j = startJ + 1;\n\n  while (j < maxJ && image.data[j + centerI * image.width]) {\n    stateCount[2]++;\n    j++;\n  }\n\n  if (j == maxJ) {\n    return NaN;\n  }\n\n  while (j < maxJ && !image.data[j + centerI * image.width] && stateCount[3] < maxCount) {\n    stateCount[3]++;\n    j++;\n  }\n\n  if (j == maxJ || stateCount[3] >= maxCount) {\n    return NaN;\n  }\n\n  while (j < maxJ && image.data[j + centerI * image.width] && stateCount[4] < maxCount) {\n    stateCount[4]++;\n    j++;\n  }\n\n  if (stateCount[4] >= maxCount) {\n    return NaN;\n  } // If we found a finder-pattern-like section, but its size is significantly different than\n  // the original, assume it's a false positive\n\n\n  var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n\n  if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n    return NaN;\n  }\n\n  return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, j) : NaN;\n};\n\nFinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i, j) {\n  var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n  var centerJ = this.centerFromEnd(stateCount, j); //float\n\n  var centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal); //float\n\n  if (!isNaN(centerI)) {\n    // Re-cross check\n    centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);\n\n    if (!isNaN(centerJ)) {\n      var estimatedModuleSize = stateCountTotal / 7.0;\n      var found = false;\n      var max = this.possibleCenters.length;\n\n      for (var index = 0; index < max; index++) {\n        var center = this.possibleCenters[index]; // Look for about the same center and module size:\n\n        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n          center.incrementCount();\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);\n        this.possibleCenters.push(point);\n\n        if (this.resultPointCallback != null) {\n          this.resultPointCallback.foundPossibleResultPoint(point);\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nFinderPatternFinder.prototype.selectBestPatterns = function () {\n  var startSize = this.possibleCenters.length;\n\n  if (startSize < 3) {\n    // Couldn't find enough finder patterns\n    throw \"Couldn't find enough finder patterns:\" + startSize + \" patterns found\";\n  } // Filter outlier possibilities whose module size is too different\n\n\n  if (startSize > 3) {\n    // But we can only afford to do so if we have at least 4 possibilities to choose from\n    var totalModuleSize = 0.0;\n    var square = 0.0;\n\n    for (var i = 0; i < startSize; i++) {\n      var centerValue = this.possibleCenters[i].estimatedModuleSize;\n      totalModuleSize += centerValue;\n      square += centerValue * centerValue;\n    }\n\n    var average = totalModuleSize / startSize;\n    this.possibleCenters.sort(function (center1, center2) {\n      var dA = Math.abs(center2.estimatedModuleSize - average);\n      var dB = Math.abs(center1.estimatedModuleSize - average);\n\n      if (dA < dB) {\n        return -1;\n      } else if (dA == dB) {\n        return 0;\n      } else {\n        return 1;\n      }\n    });\n    var stdDev = Math.sqrt(square / startSize - average * average);\n    var limit = Math.max(0.2 * average, stdDev);\n\n    for (var i = this.possibleCenters - 1; i >= 0; i--) {\n      var pattern = this.possibleCenters[i];\n\n      if (Math.abs(pattern.estimatedModuleSize - average) > limit) {\n        this.possibleCenters.splice(i, 1);\n      }\n    }\n  }\n\n  if (this.possibleCenters.length > 3) {\n    // Throw away all but those first size candidate points we found.\n    this.possibleCenters.sort(function (a, b) {\n      if (a.count > b.count) return -1;\n      if (a.count < b.count) return 1;\n      return 0;\n    });\n  }\n\n  return [this.possibleCenters[0], this.possibleCenters[1], this.possibleCenters[2]];\n};\n\nFinderPatternFinder.prototype.findRowSkip = function () {\n  var max = this.possibleCenters.length;\n\n  if (max <= 1) {\n    return 0;\n  }\n\n  var firstConfirmedCenter = null;\n\n  for (var i = 0; i < max; i++) {\n    var center = this.possibleCenters[i];\n\n    if (center.count >= CENTER_QUORUM) {\n      if (firstConfirmedCenter == null) {\n        firstConfirmedCenter = center;\n      } else {\n        // We have two confirmed centers\n        // How far down can we skip before resuming looking for the next\n        // pattern? In the worst case, only the difference between the\n        // difference in the x / y coordinates of the two centers.\n        // This is the case where you find top left last.\n        this.hasSkipped = true;\n        return Math.floor((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2);\n      }\n    }\n  }\n\n  return 0;\n};\n\nFinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {\n  var confirmedCount = 0;\n  var totalModuleSize = 0.0;\n  var max = this.possibleCenters.length;\n\n  for (var i = 0; i < max; i++) {\n    var pattern = this.possibleCenters[i];\n\n    if (pattern.count >= CENTER_QUORUM) {\n      confirmedCount++;\n      totalModuleSize += pattern.estimatedModuleSize;\n    }\n  }\n\n  if (confirmedCount < 3) {\n    return false;\n  } // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n  // and that we need to keep looking. We detect this by asking if the estimated module sizes\n  // vary too much. We arbitrarily say that when the total deviation from average exceeds\n  // 5% of the total module size estimates, it's too much.\n\n\n  var average = totalModuleSize / max;\n  var totalDeviation = 0.0;\n\n  for (var i = 0; i < max; i++) {\n    pattern = this.possibleCenters[i];\n    totalDeviation += Math.abs(pattern.estimatedModuleSize - average);\n  }\n\n  return totalDeviation <= 0.05 * totalModuleSize;\n};\n\nFinderPatternFinder.prototype.findFinderPattern = function (image) {\n  var tryHarder = false;\n  this.image = image;\n  var maxI = image.height;\n  var maxJ = image.width;\n  var iSkip = Math.floor(3 * maxI / (4 * MAX_MODULES));\n\n  if (iSkip < MIN_SKIP || tryHarder) {\n    iSkip = MIN_SKIP;\n  }\n\n  var done = false;\n  var stateCount = new Array(5);\n\n  for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {\n    // Get a row of black/white values\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0;\n    stateCount[3] = 0;\n    stateCount[4] = 0;\n    var currentState = 0;\n\n    for (var j = 0; j < maxJ; j++) {\n      if (image.data[j + i * image.width]) {\n        // Black pixel\n        if ((currentState & 1) == 1) {\n          // Counting white pixels\n          currentState++;\n        }\n\n        stateCount[currentState]++;\n      } else {\n        // White pixel\n        if ((currentState & 1) == 0) {\n          // Counting black pixels\n          if (currentState == 4) {\n            // A winner?\n            if (this.foundPatternCross(stateCount)) {\n              // Yes\n              var confirmed = this.handlePossibleCenter(stateCount, i, j);\n\n              if (confirmed) {\n                // Start examining every other line. Checking each line turned out to be too\n                // expensive and didn't improve performance.\n                iSkip = 2;\n\n                if (this.hasSkipped) {\n                  done = this.haveMultiplyConfirmedCenters();\n                } else {\n                  var rowSkip = this.findRowSkip();\n\n                  if (rowSkip > stateCount[2]) {\n                    // Skip rows between row of lower confirmed center\n                    // and top of presumed third confirmed center\n                    // but back up a bit to get a full chance of detecting\n                    // it, entire width of center of finder pattern\n                    // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                    // of pattern we saw) to be conservative, and also back off by iSkip which\n                    // is about to be re-added\n                    i += rowSkip - stateCount[2] - iSkip;\n                    j = maxJ - 1;\n                  }\n                }\n              } else {\n                // Advance to next black pixel\n                do {\n                  j++;\n                } while (j < maxJ && !image.data[j + i * image.width]);\n\n                j--; // back up to that last white pixel\n              } // Clear state to start looking again\n\n\n              currentState = 0;\n              stateCount[0] = 0;\n              stateCount[1] = 0;\n              stateCount[2] = 0;\n              stateCount[3] = 0;\n              stateCount[4] = 0;\n            } else {\n              // No, shift counts back by two\n              stateCount[0] = stateCount[2];\n              stateCount[1] = stateCount[3];\n              stateCount[2] = stateCount[4];\n              stateCount[3] = 1;\n              stateCount[4] = 0;\n              currentState = 3;\n            }\n          } else {\n            stateCount[++currentState]++;\n          }\n        } else {\n          // Counting white pixels\n          stateCount[currentState]++;\n        }\n      }\n    }\n\n    if (this.foundPatternCross(stateCount)) {\n      var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n\n      if (confirmed) {\n        iSkip = stateCount[0];\n\n        if (this.hasSkipped) {\n          // Found a third one\n          done = this.haveMultiplyConfirmedCenters();\n        }\n      }\n    }\n  }\n\n  var patternInfo = this.selectBestPatterns();\n  orderBestPatterns(patternInfo);\n  return new FinderPatternInfo(patternInfo);\n};","map":null,"metadata":{},"sourceType":"module"}