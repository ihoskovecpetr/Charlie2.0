{"ast":null,"code":"import _slicedToArray from \"/Users/petrhoskovec/Desktop/code/Charlie2.0/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useReducer, useEffect, useLayoutEffect } from 'react'; // Massive respect for Josh Johnston\n\nfunction normalizeRect(rect) {\n  if (rect.width === undefined) {\n    rect.width = rect.right - rect.left;\n  }\n\n  if (rect.height === undefined) {\n    rect.height = rect.bottom - rect.top;\n  }\n\n  return rect;\n}\n\nconst initialState = {\n  isVisible: null,\n  visibilityRect: {}\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"set\":\n      if (state.isVisible === action.payload.isVisible) {\n        return state;\n      }\n\n      return action.payload;\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_OPTIONS = {\n  intervalCheck: false,\n  partialVisibility: false,\n  containment: null,\n  scrollCheck: true,\n  scrollDebounce: 250,\n  scrollThrottle: -1,\n  resizeCheck: false,\n  resizeDebounce: 250,\n  resizeThrottle: -1,\n  shouldCheckOnMount: true,\n  minTopValue: 0\n};\n\nfunction useVisbilitySensor(ref, opts) {\n  /*\r\n      Create local state\r\n    */\n  const _useReducer = useReducer(reducer, initialState),\n        _useReducer2 = _slicedToArray(_useReducer, 2),\n        localState = _useReducer2[0],\n        dispatch = _useReducer2[1];\n  /*\r\n      Get options\r\n    */\n\n\n  const _Object$assign = Object.assign({}, DEFAULT_OPTIONS, opts),\n        containment = _Object$assign.containment,\n        intervalCheck = _Object$assign.intervalCheck,\n        scrollCheck = _Object$assign.scrollCheck,\n        shouldCheckOnMount = _Object$assign.shouldCheckOnMount,\n        scrollDebounce = _Object$assign.scrollDebounce,\n        scrollThrottle = _Object$assign.scrollThrottle,\n        resizeCheck = _Object$assign.resizeCheck,\n        resizeDebounce = _Object$assign.resizeDebounce,\n        resizeThrottle = _Object$assign.resizeThrottle,\n        partialVisibility = _Object$assign.partialVisibility,\n        minTopValue = _Object$assign.minTopValue;\n\n  function getContainer() {\n    return containment || window;\n  }\n  /*\r\n      Check visibility\r\n    */\n\n\n  function checkVisibility() {\n    let containmentRect;\n\n    if (containment) {\n      const containmentDOMRect = containment.getBoundingClientRect();\n      containmentRect = {\n        top: containmentDOMRect.top,\n        left: containmentDOMRect.left,\n        bottom: containmentDOMRect.bottom,\n        right: containmentDOMRect.right\n      };\n    } else {\n      containmentRect = {\n        top: 0,\n        left: 0,\n        bottom: window.innerHeight || document.documentElement.clientHeight,\n        right: window.innerWidth || document.documentElement.clientWidth\n      };\n    }\n\n    const rect = normalizeRect(ref.current.getBoundingClientRect());\n    const hasSize = rect.height > 0 && rect.width > 0;\n    const visibilityRect = {\n      top: rect.top >= containmentRect.top,\n      left: rect.left >= containmentRect.left,\n      bottom: rect.bottom <= containmentRect.bottom,\n      right: rect.right <= containmentRect.right\n    };\n    let isVisible = hasSize && visibilityRect.top && visibilityRect.left && visibilityRect.bottom && visibilityRect.right; // check for partial visibility\n\n    if (hasSize && partialVisibility) {\n      let partialVisible = rect.top <= containmentRect.bottom && rect.bottom >= containmentRect.top && rect.left <= containmentRect.right && rect.right >= containmentRect.left; // account for partial visibility on a single edge\n\n      if (typeof partialVisibility === \"string\") {\n        partialVisible = visibilityRect[partialVisibility];\n      } // if we have minimum top visibility set by props, lets check, if it meets the passed value\n      // so if for instance element is at least 200px in viewport, then show it.\n\n\n      isVisible = minTopValue ? partialVisible && rect.top <= containmentRect.bottom - minTopValue : partialVisible;\n    }\n\n    return {\n      isVisible,\n      visibilityRect\n    };\n  }\n\n  function updateIsVisible() {\n    if (!ref.current) {\n      return;\n    }\n\n    const _checkVisibility = checkVisibility(),\n          isVisible = _checkVisibility.isVisible,\n          visibilityRect = _checkVisibility.visibilityRect;\n\n    dispatch({\n      type: \"set\",\n      payload: {\n        isVisible,\n        visibilityRect\n      }\n    });\n  } // run only once, hence empty array as second argument\n\n\n  useEffect(() => {\n    if (shouldCheckOnMount) {\n      updateIsVisible();\n    }\n  }, []);\n  useEffect(() => {\n    updateIsVisible();\n  }, [ref.current]); // If interval check is needed\n\n  useEffect(() => {\n    if (intervalCheck && intervalCheck > 0) {\n      const intervalTimer = setInterval(() => {\n        updateIsVisible();\n      }, intervalCheck);\n      return () => {\n        clearInterval(intervalTimer);\n      };\n    }\n  }, [intervalCheck]);\n\n  function createListener(event, debounce, throttle) {\n    const container = getContainer();\n    let timeout;\n    let listener;\n\n    const later = () => {\n      timeout = null;\n      updateIsVisible();\n    };\n\n    if (throttle > -1) {\n      listener = () => {\n        if (!timeout) {\n          timeout = setTimeout(later, throttle || 0);\n        }\n      };\n    } else {\n      listener = () => {\n        clearTimeout(timeout);\n        timeout = setTimeout(later, debounce || 0);\n      };\n    }\n\n    container.addEventListener(event, listener);\n    return () => {\n      clearTimeout(timeout);\n      container.removeEventListener(event, listener);\n    };\n  } // If scroll check is needed\n\n\n  useLayoutEffect(() => {\n    if (scrollCheck) {\n      return createListener(\"scroll\", scrollDebounce, scrollThrottle);\n    }\n  }, []); // if resize check is needed\n\n  useLayoutEffect(() => {\n    if (resizeCheck) {\n      return createListener(\"resize\", resizeDebounce, resizeThrottle);\n    }\n  }, []);\n  return localState;\n}\n\nexport default useVisbilitySensor;","map":null,"metadata":{},"sourceType":"module"}