{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n'use strict';\n\nvar logging = require('../utils.js').log;\n\nvar browserDetails = require('../utils.js').browserDetails;\n\nvar chromeShim = {\n  shimMediaStream: function () {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n  shimOnTrack: function () {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function () {\n          return this._ontrack;\n        },\n        set: function (f) {\n          var self = this;\n\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function (e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function (te) {\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = {\n                track: te.track\n              };\n              event.streams = [e.stream];\n              self.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function (track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = {\n                track: track\n              };\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n  },\n  shimSourceObject: function () {\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function () {\n            return this._srcObject;\n          },\n          set: function (stream) {\n            var self = this; // Use _srcObject as a private property for this shim\n\n            this._srcObject = stream;\n\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return;\n            }\n\n            this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n\n            stream.addEventListener('addtrack', function () {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function () {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n  shimPeerConnection: function () {\n    // The RTCPeerConnection object.\n    window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n      // Translate iceTransportPolicy to iceTransports,\n      // see https://code.google.com/p/webrtc/issues/detail?id=4869\n      logging('PeerConnection');\n\n      if (pcConfig && pcConfig.iceTransportPolicy) {\n        pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n      }\n\n      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);\n      var origGetStats = pc.getStats.bind(pc);\n\n      pc.getStats = function (selector, successCallback, errorCallback) {\n        var self = this;\n        var args = arguments; // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n\n        if (arguments.length > 0 && typeof selector === 'function') {\n          return origGetStats(selector, successCallback);\n        }\n\n        var fixChromeStats_ = function (response) {\n          var standardReport = {};\n          var reports = response.result();\n          reports.forEach(function (report) {\n            var standardStats = {\n              id: report.id,\n              timestamp: report.timestamp,\n              type: report.type\n            };\n            report.names().forEach(function (name) {\n              standardStats[name] = report.stat(name);\n            });\n            standardReport[standardStats.id] = standardStats;\n          });\n          return standardReport;\n        }; // shim getStats with maplike support\n\n\n        var makeMapStats = function (stats, legacyStats) {\n          var map = new Map(Object.keys(stats).map(function (key) {\n            return [key, stats[key]];\n          }));\n          legacyStats = legacyStats || stats;\n          Object.keys(legacyStats).forEach(function (key) {\n            map[key] = legacyStats[key];\n          });\n          return map;\n        };\n\n        if (arguments.length >= 2) {\n          var successCallbackWrapper_ = function (response) {\n            args[1](makeMapStats(fixChromeStats_(response)));\n          };\n\n          return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);\n        } // promise-support\n\n\n        return new Promise(function (resolve, reject) {\n          if (args.length === 1 && typeof selector === 'object') {\n            origGetStats.apply(self, [function (response) {\n              resolve(makeMapStats(fixChromeStats_(response)));\n            }, reject]);\n          } else {\n            // Preserve legacy chrome stats only on legacy access of stats obj\n            origGetStats.apply(self, [function (response) {\n              resolve(makeMapStats(fixChromeStats_(response), response.result()));\n            }, reject]);\n          }\n        }).then(successCallback, errorCallback);\n      };\n\n      return pc;\n    };\n\n    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.\n\n    if (webkitRTCPeerConnection.generateCertificate) {\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function () {\n          return webkitRTCPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    ['createOffer', 'createAnswer'].forEach(function (method) {\n      var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\n      webkitRTCPeerConnection.prototype[method] = function () {\n        var self = this;\n\n        if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') {\n          var opts = arguments.length === 1 ? arguments[0] : undefined;\n          return new Promise(function (resolve, reject) {\n            nativeMethod.apply(self, [resolve, reject, opts]);\n          });\n        }\n\n        return nativeMethod.apply(this, arguments);\n      };\n    }); // add promise support -- natively available in Chrome 51\n\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n        var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\n        webkitRTCPeerConnection.prototype[method] = function () {\n          var args = arguments;\n          var self = this;\n          var promise = new Promise(function (resolve, reject) {\n            nativeMethod.apply(self, [args[0], resolve, reject]);\n          });\n\n          if (args.length < 2) {\n            return promise;\n          }\n\n          return promise.then(function () {\n            args[1].apply(null, []);\n          }, function (err) {\n            if (args.length >= 3) {\n              args[2].apply(null, [err]);\n            }\n          });\n        };\n      });\n    } // support for addIceCandidate(null)\n\n\n    var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate;\n\n    RTCPeerConnection.prototype.addIceCandidate = function () {\n      return arguments[0] === null ? Promise.resolve() : nativeAddIceCandidate.apply(this, arguments);\n    }; // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n\n\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\n      webkitRTCPeerConnection.prototype[method] = function () {\n        arguments[0] = new (method === 'addIceCandidate' ? RTCIceCandidate : RTCSessionDescription)(arguments[0]);\n        return nativeMethod.apply(this, arguments);\n      };\n    });\n  },\n  // Attach a media stream to an element.\n  attachMediaStream: function (element, stream) {\n    logging('DEPRECATED, attachMediaStream will soon be removed.');\n\n    if (browserDetails.version >= 43) {\n      element.srcObject = stream;\n    } else if (typeof element.src !== 'undefined') {\n      element.src = URL.createObjectURL(stream);\n    } else {\n      logging('Error attaching stream to element.');\n    }\n  },\n  reattachMediaStream: function (to, from) {\n    logging('DEPRECATED, reattachMediaStream will soon be removed.');\n\n    if (browserDetails.version >= 43) {\n      to.srcObject = from.srcObject;\n    } else {\n      to.src = from.src;\n    }\n  }\n}; // Expose public methods.\n\nmodule.exports = {\n  shimMediaStream: chromeShim.shimMediaStream,\n  shimOnTrack: chromeShim.shimOnTrack,\n  shimSourceObject: chromeShim.shimSourceObject,\n  shimPeerConnection: chromeShim.shimPeerConnection,\n  shimGetUserMedia: require('./getusermedia'),\n  attachMediaStream: chromeShim.attachMediaStream,\n  reattachMediaStream: chromeShim.reattachMediaStream\n};","map":null,"metadata":{},"sourceType":"script"}