{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { URShift } from './qrcode';\nimport ErrorCorrectionLevel from './errorlevel';\nvar FORMAT_INFO_MASK_QR = 0x5412;\nvar FORMAT_INFO_DECODE_LOOKUP = [[0x5412, 0x00], [0x5125, 0x01], [0x5E7C, 0x02], [0x5B4B, 0x03], [0x45F9, 0x04], [0x40CE, 0x05], [0x4F97, 0x06], [0x4AA0, 0x07], [0x77C4, 0x08], [0x72F3, 0x09], [0x7DAA, 0x0A], [0x789D, 0x0B], [0x662F, 0x0C], [0x6318, 0x0D], [0x6C41, 0x0E], [0x6976, 0x0F], [0x1689, 0x10], [0x13BE, 0x11], [0x1CE7, 0x12], [0x19D0, 0x13], [0x0762, 0x14], [0x0255, 0x15], [0x0D0C, 0x16], [0x083B, 0x17], [0x355F, 0x18], [0x3068, 0x19], [0x3F31, 0x1A], [0x3A06, 0x1B], [0x24B4, 0x1C], [0x2183, 0x1D], [0x2EDA, 0x1E], [0x2BED, 0x1F]];\nvar BITS_SET_IN_HALF_BYTE = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];\nexport default function FormatInformation(formatInfo) {\n  this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 0x03);\n  this.dataMask = formatInfo & 0x07;\n}\n\nFormatInformation.prototype.GetHashCode = function () {\n  return this.errorCorrectionLevel.ordinal() << 3 | this.dataMask;\n};\n\nFormatInformation.prototype.Equals = function (o) {\n  var other = o;\n  return this.errorCorrectionLevel == other.errorCorrectionLevel && this.dataMask == other.dataMask;\n};\n\nFormatInformation.numBitsDiffering = function (a, b) {\n  a ^= b; // a now has a 1 bit exactly where its bit differs with b's\n  // Count bits set quickly with a series of lookups:\n\n  return BITS_SET_IN_HALF_BYTE[a & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 4) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 8) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 12) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 16) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 20) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 24) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 28) & 0x0F];\n};\n\nFormatInformation.decodeFormatInformation = function (maskedFormatInfo) {\n  var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo);\n\n  if (formatInfo != null) {\n    return formatInfo;\n  } // Should return null, but, some QR codes apparently\n  // do not mask this info. Try again by actually masking the pattern\n  // first\n\n\n  return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR);\n};\n\nFormatInformation.doDecodeFormatInformation = function (maskedFormatInfo) {\n  // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n  var bestDifference = 0xffffffff;\n  var bestFormatInfo = 0;\n\n  for (var i = 0; i < FORMAT_INFO_DECODE_LOOKUP.length; i++) {\n    var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];\n    var targetInfo = decodeInfo[0];\n\n    if (targetInfo == maskedFormatInfo) {\n      // Found an exact match\n      return new FormatInformation(decodeInfo[1]);\n    }\n\n    var bitsDifference = this.numBitsDiffering(maskedFormatInfo, targetInfo);\n\n    if (bitsDifference < bestDifference) {\n      bestFormatInfo = decodeInfo[1];\n      bestDifference = bitsDifference;\n    }\n  } // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n  // differing means we found a match\n\n\n  if (bestDifference <= 3) {\n    return new FormatInformation(bestFormatInfo);\n  }\n\n  return null;\n};","map":null,"metadata":{},"sourceType":"module"}