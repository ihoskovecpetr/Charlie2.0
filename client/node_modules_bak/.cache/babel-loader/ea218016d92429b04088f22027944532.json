{"ast":null,"code":"/*\n  Ported to JavaScript by Lazar Laszlo 2011\n\n  lazarsoft@gmail.com, www.lazarsoft.info\n\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport GF256 from './gf256';\nimport GF256Poly from './gf256poly';\nexport default function ReedSolomonDecoder(field) {\n  this.field = field;\n}\n\nReedSolomonDecoder.prototype.decode = function (received, twoS) {\n  var poly = new GF256Poly(this.field, received);\n  var syndromeCoefficients = new Array(twoS);\n\n  for (var i = 0; i < syndromeCoefficients.length; i++) syndromeCoefficients[i] = 0;\n\n  var dataMatrix = false; //this.field.Equals(GF256.DATA_MATRIX_FIELD);\n\n  var noError = true;\n\n  for (var i = 0; i < twoS; i++) {\n    // Thanks to sanfordsquires for this fix:\n    var _eval = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));\n\n    syndromeCoefficients[syndromeCoefficients.length - 1 - i] = _eval;\n\n    if (_eval != 0) {\n      noError = false;\n    }\n  }\n\n  if (noError) {\n    return;\n  }\n\n  var syndrome = new GF256Poly(this.field, syndromeCoefficients);\n  var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);\n  var sigma = sigmaOmega[0];\n  var omega = sigmaOmega[1];\n  var errorLocations = this.findErrorLocations(sigma);\n  var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);\n\n  for (var i = 0; i < errorLocations.length; i++) {\n    var position = received.length - 1 - this.field.log(errorLocations[i]);\n\n    if (position < 0) {\n      throw \"ReedSolomonException Bad error location\";\n    }\n\n    received[position] = GF256.prototype.addOrSubtract(received[position], errorMagnitudes[i]);\n  }\n};\n\nReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R) {\n  // Assume a's degree is >= b's\n  if (a.Degree < b.Degree) {\n    var temp = a;\n    a = b;\n    b = temp;\n  }\n\n  var rLast = a;\n  var r = b;\n  var sLast = this.field.One;\n  var s = this.field.Zero;\n  var tLast = this.field.Zero;\n  var t = this.field.One; // Run Euclidean algorithm until r's degree is less than R/2\n\n  while (r.Degree >= Math.floor(R / 2)) {\n    var rLastLast = rLast;\n    var sLastLast = sLast;\n    var tLastLast = tLast;\n    rLast = r;\n    sLast = s;\n    tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n    if (rLast.Zero) {\n      // Oops, Euclidean algorithm already terminated?\n      throw \"r_{i-1} was zero\";\n    }\n\n    r = rLastLast;\n    var q = this.field.Zero;\n    var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);\n    var dltInverse = this.field.inverse(denominatorLeadingTerm);\n\n    while (r.Degree >= rLast.Degree && !r.Zero) {\n      var degreeDiff = r.Degree - rLast.Degree;\n      var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);\n      q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));\n      r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n    }\n\n    s = q.multiply1(sLast).addOrSubtract(sLastLast);\n    t = q.multiply1(tLast).addOrSubtract(tLastLast);\n  }\n\n  var sigmaTildeAtZero = t.getCoefficient(0);\n\n  if (sigmaTildeAtZero == 0) {\n    throw \"ReedSolomonException sigmaTilde(0) was zero\";\n  }\n\n  var inverse = this.field.inverse(sigmaTildeAtZero);\n  var sigma = t.multiply2(inverse);\n  var omega = r.multiply2(inverse);\n  return [sigma, omega];\n};\n\nReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\n  // This is a direct application of Chien's search\n  var numErrors = errorLocator.Degree;\n\n  if (numErrors == 1) {\n    // shortcut\n    return new Array(errorLocator.getCoefficient(1));\n  }\n\n  var result = new Array(numErrors);\n  var e = 0;\n\n  for (var i = 1; i < 256 && e < numErrors; i++) {\n    if (errorLocator.evaluateAt(i) == 0) {\n      result[e] = this.field.inverse(i);\n      e++;\n    }\n  }\n\n  if (e != numErrors) {\n    throw \"Error locator degree does not match number of roots\";\n  }\n\n  return result;\n};\n\nReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations, dataMatrix) {\n  // This is directly applying Forney's Formula\n  var s = errorLocations.length;\n  var result = new Array(s);\n\n  for (var i = 0; i < s; i++) {\n    var xiInverse = this.field.inverse(errorLocations[i]);\n    var denominator = 1;\n\n    for (var j = 0; j < s; j++) {\n      if (i != j) {\n        denominator = this.field.multiply(denominator, GF256.prototype.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)));\n      }\n    }\n\n    result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator)); // Thanks to sanfordsquires for this fix:\n\n    if (dataMatrix) {\n      result[i] = this.field.multiply(result[i], xiInverse);\n    }\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}